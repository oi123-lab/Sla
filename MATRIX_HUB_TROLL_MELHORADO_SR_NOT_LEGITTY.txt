-- Intro GUI
local introGui = Instance.new("ScreenGui")
introGui.Name = "IntroGUI"
introGui.ResetOnSpawn = false
introGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0.4, 0, 0.2, 0)
frame.Position = UDim2.new(0.3, 0, 0.4, 0)
frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
frame.BorderSizePixel = 0
frame.BackgroundTransparency = 0.3
frame.Parent = introGui

local textLabel = Instance.new("TextLabel")
textLabel.Size = UDim2.new(1, 0, 1, 0)
textLabel.BackgroundTransparency = 1
textLabel.Text = "By Not Legitty..."
textLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
textLabel.TextScaled = true
textLabel.Font = Enum.Font.GothamBold
textLabel.Parent = frame

-- Espera um tempo antes de carregar o hub
task.wait(3)

-- Remove a intro
introGui:Destroy()

-- Carrega o Redzhubui
local Library=
loadstring(game:HttpGet("https://pastebin.com/raw/DTB6QZfY"))()






local Window = Library:MakeWindow({
    Title = "‚òÖ‚ò†Matrix Hub O Retorno v4.6‚ò†‚òÖ: BROOKHAVEN RPüè°",
    SubTitle = "By : Matrix Community Rework",
    SaveFolder = "MATRIXHUB Folder"
})

Window:AddMinimizeButton({
    Button = { Image = "rbxassetid://85219327131493", BackgroundTransparency = 0 }, -- Coloque um ID v√°lido
    Corner = { CornerRadius = UDim.new(0, 10) }
})

local Tab1 = Window:MakeTab({"Home", "rbxassetid://138700382840270"})

local Section = Tab1:AddSection("Cr√©ditos: Matrix COMMUNITY,E Shelby")

Tab1:AddParagraph({"üîß Interface Reformulada: Nova estrutura visual com foco em efici√™ncia e organiza√ß√£o."})
Tab1:AddParagraph({"‚öôÔ∏è HUB ATUALIZADA COM NOVAS FUNCIONALIDADES INOVADORAS."})
Tab1:AddParagraph({"‚úÖ Estabilidade Aprimorada: Menor chance de falhas e resposta mais r√°pida do sistema."})

local playerName = game.Players.LocalPlayer.Name
Tab1:AddParagraph({"Ol√°, " .. playerName .. "! ‚òÑ Seja bem-vindo ao MATRIX HUBüé©. Aproveite com responsabilidade e Cuidado."})

local Tab2 = Window:MakeTab({"Troll", "Skull"})

local Section = Tab2:AddSection({"Troll Area By Not legitty,By Shelby"})

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local CurrentCamera = workspace.CurrentCamera
local RunService = game:GetService("RunService")

local viewEnabled = false
local currentTarget = nil
local characterAddedConn = nil
local playerNames = {}

-- Fun√ß√£o para atualizar a lista de jogadores
local function updateDropdown()
    playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    if Dropdown then
        Dropdown:Set(playerNames)
    end
end

-- Fun√ß√£o para tratar a adi√ß√£o de novos jogadores
local function onPlayerAdded(player)
    if player ~= LocalPlayer then
        table.insert(playerNames, player.Name)
        if Dropdown then
            Dropdown:Set(playerNames)
        end
    end
end

-- Fun√ß√£o para tratar a remo√ß√£o de jogadores
local function onPlayerRemoving(player)
    for i, name in ipairs(playerNames) do
        if name == player.Name then
            table.remove(playerNames, i)
            break
        end
    end
    if Dropdown then
        Dropdown:Set(playerNames)
    end

    if currentTarget == player then
        stopViewing()
    end
end

-- Atualizando dropdown com lista de jogadores ao iniciar
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)
task.delay(1, updateDropdown)

-- Fun√ß√£o para resetar a c√¢mera do jogador local
local function resetCamera()
    if LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() then
        CurrentCamera.CameraSubject = LocalPlayer.Character
    end
end

-- Fun√ß√£o para fazer a transi√ß√£o da c√¢mera para o alvo
local function tweenToTargetPart(part)
    local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local targetCFrame = part.CFrame + part.CFrame.LookVector * -10 + Vector3.new(0, 5, 0)
    local goal = {CFrame = CFrame.new(targetCFrame.Position, part.Position)}
    local tween = TweenService:Create(CurrentCamera, tweenInfo, goal)
    tween:Play()
end

-- Fun√ß√£o para configurar a visualiza√ß√£o do alvo
function setViewTarget(targetName)
    local targetPlayer = Players:FindFirstChild(targetName)
    if not targetPlayer then
        warn("[VIEW] Jogador n√£o encontrado: " .. targetName)
        return
    end

    currentTarget = targetPlayer

    -- Desconectar qualquer conex√£o anterior
    if characterAddedConn then
        characterAddedConn:Disconnect()
    end

    characterAddedConn = targetPlayer.CharacterAdded:Connect(function(char)
        task.wait(0.1)
        if viewEnabled and currentTarget == targetPlayer then
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                tweenToTargetPart(hrp)
            end
            pcall(function()
                CurrentCamera.CameraSubject = char
            end)
        end
    end)

    -- Verificar o personagem j√° existente
    if targetPlayer.Character then
        local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            tweenToTargetPart(hrp)
        end
        pcall(function()
            CurrentCamera.CameraSubject = targetPlayer.Character
        end)
    end
end

-- Fun√ß√£o para parar a visualiza√ß√£o
function stopViewing()
    viewEnabled = false
    currentTarget = nil
    if characterAddedConn then
        characterAddedConn:Disconnect()
        characterAddedConn = nil
    end
    resetCamera()
end

-- Render loop para atualizar a visualiza√ß√£o
RunService.RenderStepped:Connect(function()
    if viewEnabled and currentTarget then
        if not currentTarget:IsDescendantOf(game) then
            stopViewing()
            return
        end
        if currentTarget.Character and CurrentCamera.CameraSubject ~= currentTarget.Character then
            pcall(function()
                CurrentCamera.CameraSubject = currentTarget.Character
            end)
        end
    end
end)

-- Adicionando o Dropdown para sele√ß√£o de jogador
Dropdown = Tab2:AddDropdown({
    Name = "Selecione o Player.",
    Options = playerNames,
    Default = {},
    MultiSelect = false,
    Callback = function(Value)
        if typeof(Value) == "string" and Players:FindFirstChild(Value) then
            getgenv().Target = Value
            if viewEnabled then
                setViewTarget(Value)
            end
        end
    end
})

-- Toggle para ativar/desativar a visualiza√ß√£o
Tab2:AddToggle({
    Name = "View",
    Default = false,
    Callback = function(state)
        viewEnabled = state
        if state and getgenv().Target then
            setViewTarget(getgenv().Target)
        else
            stopViewing()
        end
    end
})

-- Atualizando o Dropdown quando um jogador entra ou sai
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)
task.delay(1, updateDropdown)

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

Tab2:AddButton({
	Name = "Goto",
	Callback = function()
		local success, err = pcall(function()
			local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
			local hrp = character:FindFirstChild("HumanoidRootPart")

			if not hrp then return end

			local targetName = getgenv().Target
			if not targetName then
				warn("[GOTO] Nenhum alvo definido.")
				return
			end

			local targetPlayer = Players:FindFirstChild(targetName)
			if not targetPlayer or not targetPlayer.Character then
				warn("[GOTO] Alvo inv√°lido ou n√£o encontrado.")
				return
			end

			local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
			if not targetHRP then
				warn("[GOTO] Alvo sem HumanoidRootPart.")
				return
			end

			-- Tween suave de teleporte
			local goal = {CFrame = targetHRP.CFrame + Vector3.new(0, 5, 0)}
			local tween = TweenService:Create(hrp, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), goal)
			tween:Play()
		end)

		if not success then
			warn("[GOTO] Erro ao tentar teleportar:", err)
		end
	end
})

local Section = Tab2:AddSection({"<Combat Ball Area‚öΩÔ∏è-"})

-- Servi√ßos
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Jogador local e caminho da bola
local localPlayer = Players.LocalPlayer
local BALL_PATH = "WorkspaceCom/001_SoccerBalls/Soccer" .. localPlayer.Name

-- Vari√°veis globais
getgenv().Target = nil
local ball, connection

-- Remove qualquer for√ßa existente na bola
local function clearForces(targetBall)
	for _, obj in ipairs(targetBall:GetChildren()) do
		if obj:IsA("BodyForce") or obj:IsA("BodyVelocity") or obj:IsA("BodyPosition") then
			obj:Destroy()
		end
	end
end

-- Ignora colis√£o entre a bola e o personagem
local function ignorePlayerCollision(targetBall, targetCharacter)
	for _, part in ipairs(targetCharacter:GetDescendants()) do
		if part:IsA("BasePart") then
			local constraint = Instance.new("NoCollisionConstraint")
			constraint.Part0 = targetBall
			constraint.Part1 = part
			constraint.Parent = targetBall
		end
	end
end

-- Configura a bola para seguir o alvo e causar fling com BodyPosition pr√≥ximo
function setupBall()
	local targetName = getgenv().Target
	if not targetName then
		warn("Nenhum jogador selecionado.")
		return
	end

	local targetPlayer = Players:FindFirstChild(targetName)
	if not targetPlayer then
		warn("Jogador alvo n√£o encontrado.")
		return
	end

	local character = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
	local torso = character:WaitForChild("UpperTorso", 5) or character:WaitForChild("Torso", 5)

	local success, foundBall = pcall(function()
		local obj = workspace
		for _, part in ipairs(BALL_PATH:split("/")) do
			obj = obj:WaitForChild(part, 5)
		end
		return obj
	end)

	if not success or not foundBall then
		warn("Bola n√£o encontrada.")
		return
	end

	ball = foundBall
	ball.Anchored = false
	ball.CanCollide = true
	ball.Massless = false

	clearForces(ball)
	ignorePlayerCollision(ball, character)

	-- For√ßa leve constante pra manter a bola flutuando
	local bodyForce = Instance.new("BodyForce")
	bodyForce.Force = Vector3.new(0, ball:GetMass() * workspace.Gravity, 0)
	bodyForce.Parent = ball

	local bodyPosition = Instance.new("BodyPosition")
	bodyPosition.MaxForce = Vector3.new(1e6, 1e6, 1e6)
	bodyPosition.P = 5e4
	bodyPosition.D = 1500
	bodyPosition.Parent = ball

	if connection then
		connection:Disconnect()
	end

	local toggle = true
	connection = RunService.Heartbeat:Connect(function()
    if not ball or not torso then
        connection:Disconnect()
        return
    end
    bodyPosition.Position = torso.Position + Vector3.new(0, 1, 0)
end)

	-- Reconecta caso o alvo renas√ßa
	targetPlayer.CharacterAdded:Connect(function()
		task.wait(1)
		setupBall()
	end)
end

-- Bot√£o que ativa o Fling com base no alvo selecionado
Tab2:AddButton({
	Name = "Fling Ball",
	Callback = function()
		if getgenv().Target then
			setupBall()
		else
			warn("Nenhum jogador selecionado. Use a dropdown primeiro.")
		end
	end
})

local Section = Tab2:AddSection({"<Combat Couch Areaüõã-"})

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Backpack = Player:FindFirstChild("Backpack")
local AllBool = false

getgenv().Target = nil -- Alvo global
getgenv().OldPos = nil -- Posi√ß√£o inicial antes do Fling

local function GetPlayer(Name)
    Name = Name:lower()
    for _, x in next, Players:GetPlayers() do
        if x ~= Player then
            if x.Name:lower():match("^" .. Name) or x.DisplayName:lower():match("^" .. Name) then
                return x
            end
        end
    end
    return nil
end

local function EquipCouch()
    if Backpack then
        local Couch = Backpack:FindFirstChild("Couch")
        if Couch and not Player.Character:FindFirstChild("Couch") then
            Player.Character.Humanoid:EquipTool(Couch)
        end
    end
end

local function UnequipCouch()
    if Player.Character then
        local Tool = Player.Character:FindFirstChildOfClass("Tool")
        if Tool and Tool.Name == "Couch" then
            Tool.Parent = Backpack
        end
    end
end

local function SafeReturn()
    local Player = game.Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")

    if not RootPart or not Humanoid then  
        warn("RootPart ou Humanoid n√£o encontrado.")  
        return  
    end  

    -- Configura√ß√£o da posi√ß√£o fixa de retorno  
    local fixedReturnPos = Vector3.new(1118.81, 75.998, -1138.61)  

    -- Paralisa e trava o jogador  
    Humanoid.PlatformStand = true  
    RootPart.Anchored = true  
    RootPart.AssemblyLinearVelocity = Vector3.zero  
    RootPart.AssemblyAngularVelocity = Vector3.zero  

    -- Move direto para a posi√ß√£o definida  
    RootPart.CFrame = CFrame.new(fixedReturnPos)  
    print("Jogador teleportado para a posi√ß√£o segura.")  

    -- Fica travado por 3 segundos pra estabilizar  
    task.wait(3)  

    -- Libera o jogador  
    RootPart.Anchored = false  
    Humanoid.PlatformStand = false  
    print("Jogador liberado com seguran√ßa.")  
end

local function SkidFling(TargetPlayer)
    if not TargetPlayer then
        return
    end

    EquipCouch() -- Equipa o item Couch antes de iniciar o fling  

    local Character = Player.Character  
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")  
    local RootPart = Humanoid and Humanoid.RootPart  

    local TCharacter = TargetPlayer.Character  
    local TRootPart = TCharacter and TCharacter:FindFirstChild("HumanoidRootPart")  

    if not Character or not Humanoid or not RootPart or not TCharacter or not TRootPart then  
        return  
    end  

    -- Salva a posi√ß√£o inicial do jogador antes de iniciar o fling  
    if not getgenv().OldPos then  
        getgenv().OldPos = RootPart.CFrame  
    end  

    if RootPart.Velocity.Magnitude < 50 then  
        getgenv().OldPos = RootPart.CFrame  
    end  

    if TCharacter:FindFirstChildWhichIsA("Seat") then  
        UnequipCouch() -- Se o alvo estiver sentado, desequipa o Couch  
        return  
    end  

    local function FPos(BasePart, Pos, Ang)  
        RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang  
        Character:SetPrimaryPartCFrame(RootPart.CFrame)  
    end  

    local function SFBasePart(BasePart)  
        local StartTime = tick()  
        local Angle = 0  

        local BV = Instance.new("BodyVelocity")  
        BV.Parent = RootPart  
        BV.Velocity = Vector3.new(1000, 1000, 1000)  
        BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)  

        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)  

        repeat  
            Angle = Angle + 100  

            local THumanoid = TargetPlayer.Character:FindFirstChildOfClass("Humanoid")  
            local TRootPart = TCharacter and TCharacter:FindFirstChild("HumanoidRootPart")  

            if THumanoid then  
                if TCharacter:FindFirstChildWhichIsA("Seat") then  
                    UnequipCouch() -- Se o alvo sentar, desequipa o Couch  
                    return  
                end  

                -- Ajustando a altura e rota√ß√£o no alvo  
                FPos(BasePart, CFrame.new(0, 2, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(2.5, 2, -2.5) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(-2.5, -2, 2.5) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, 2, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))  
                task.wait()  
            else  
                -- Comportamento alternativo se o humanoide n√£o for encontrado  
                FPos(BasePart, CFrame.new(0, 2, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, 2, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, 2, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, 2, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, 0), CFrame.Angles(math.rad(90), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, 0), CFrame.Angles(0, 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, 0), CFrame.Angles(math.rad(-90), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, 0), CFrame.Angles(0, 0, 0))  
                task.wait()  
            end  
        until tick() > StartTime + 3 -- Fling dura 3 segundos  

        -- No √∫ltimo segundo, desequipa o Couch e tira as for√ßas  
        UnequipCouch()  

        -- Remove a for√ßa de impulso e velocity  
        BV:Destroy()  

        -- Volta √† posi√ß√£o original com altura corrigida  
        local ReturnPos = getgenv().OldPos  
        if RootPart.Position.Y > ReturnPos.Position.Y then  
            -- Se o jogador foi lan√ßado para uma posi√ß√£o mais alta, devolve ele para a posi√ß√£o original com altura ajustada  
            ReturnPos = CFrame.new(ReturnPos.Position.X, ReturnPos.Position.Y - (RootPart.Position.Y - ReturnPos.Position.Y), ReturnPos.Position.Z)  
        end  

        -- Desabilita a f√≠sica antes de devolver o jogador  
        Humanoid.PlatformStand = true  

        -- Restaura a posi√ß√£o do jogador  
        RootPart.CFrame = ReturnPos  

        -- Habilita a f√≠sica novamente ap√≥s a restaura√ß√£o da posi√ß√£o  
        task.wait(1)  
        Humanoid.PlatformStand = false  
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)

        -- Chama a fun√ß√£o de retorno seguro ap√≥s o Fling
        SafeReturn()
    end  

workspace.FallenPartsDestroyHeight = -math.huge  

SFBasePart(TRootPart)

end

Tab2:AddButton({
    Name = "Fling Couch",
    Callback = function()
        if getgenv().Target then
            local TargetPlayer = GetPlayer(getgenv().Target)
            if TargetPlayer then
                SkidFling(TargetPlayer)
            end
        end
    end
})


local Section = Tab2:AddSection({"<Combat Vehicle Areaüöó-"})

Tab2:AddButton({
    Name = " Bus - Fling",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart and RootPart.CFrame

        if not Humanoid or not RootPart then return end

        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if not PCar then
            RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
            task.wait(0.5)
            local Remote = game.ReplicatedStorage:FindFirstChild("RE") and game.ReplicatedStorage.RE:FindFirstChild("1Ca1r")
            if Remote then Remote:FireServer("PickingCar", "SchoolBus") end
            task.wait(0.5)
            PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        end

        local timeout = 5
        while timeout > 0 and not PCar do
            task.wait(0.25)
            PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            timeout -= 0.25
        end
        if not PCar then return end

        task.wait(0.5)
        if PCar and not Humanoid.Sit then
            local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
            if Seat then
                repeat task.wait()
                    RootPart.CFrame = Seat.CFrame
                until Humanoid.Sit
            end
        end

        local attachment = nil
        local force = nil

        -- Fun√ß√£o segura para recuperar alvo continuamente
        local function getTargetInfo()
            while true do
                local TargetPlayer = game.Players:FindFirstChild(getgenv().Target)
                if TargetPlayer then
                    local TargetC = TargetPlayer.Character
                    local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
                    local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")
                    if TargetC and TargetH and TargetRP then
                        return TargetC, TargetH, TargetRP
                    end
                end
                task.wait(0.2)
            end
        end

        local TargetC, TargetH, TargetRP = getTargetInfo()

        -- Aplica BodyVelocity no alvo
        attachment = Instance.new("Attachment", TargetRP)
        force = Instance.new("BodyVelocity")
        force.Velocity = Vector3.new(1e9, 1e9, 1e9)
        force.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        force.P = 500
        force.Parent = attachment

        for _, part in ipairs(PCar:GetDescendants()) do
            if part:IsA("BasePart") then
                local bv = Instance.new("BodyVelocity")
                bv.Velocity = Vector3.new(1e9, 1e9, 1e9)
                bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bv.P = 500
                bv.Parent = part
            end
        end

        -- Loop principal com persist√™ncia
        local Angles = 0
        local YRotation = 0

        while PCar.Parent do
            task.wait()
            Angles += 100
            YRotation += 5000
            local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

            -- Verifica se o alvo ainda existe; se n√£o, espera o retorno
            if not (TargetC and TargetH and TargetRP and TargetRP.Parent) then
                TargetC, TargetH, TargetRP = getTargetInfo()
                if attachment then attachment:Destroy() end
                if force then force:Destroy() end
                attachment = Instance.new("Attachment", TargetRP)
                force = Instance.new("BodyVelocity")
                force.Velocity = Vector3.new(1e9, 1e9, 1e9)
                force.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                force.P = 500
                force.Parent = attachment
            end

            local function flingAttack(offset)
                local newPos = TargetRP.Position + offset + (TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.1)
                local newCF = CFrame.new(newPos) * Rotation
                PCar:SetPrimaryPartCFrame(newCF)
            end

            flingAttack(Vector3.new(0, 1, 0))
            flingAttack(Vector3.new(0, -2.25, 5))
            flingAttack(Vector3.new(0, 2.25, 0.25))
            flingAttack(Vector3.new(-2.25, -1.5, 2.25))
            flingAttack(Vector3.new(0, 1.5, 0))
            flingAttack(Vector3.new(0, -1.5, 0))
        end

        -- Finaliza√ß√£o
        if attachment then attachment:Destroy() end
        if force then force:Destroy() end
        Humanoid.Sit = false
        task.wait(0.1)
        if OldPos then RootPart.CFrame = OldPos end
    end
})

Tab2:AddButton({
    Name = "Delisgar Fling - Bus",
    Callback = function()
        -- Executa o remote para deletar todos os ve√≠culos
        local args = {
            [1] = "DeleteAllVehicles"
        }
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer(unpack(args))

        -- Aguarda um frame para garantir que o remote foi processado (opcional, mas prudente)
        task.wait()

        local Player = game.Players.LocalPlayer
        local Character = Player.Character or Player.CharacterAdded:Wait()
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")

        if not RootPart or not Humanoid then
            warn("RootPart ou Humanoid n√£o encontrado.")
            return
        end

        -- Configura√ß√£o da posi√ß√£o fixa de retorno
        local fixedReturnPos = Vector3.new(1118.81, 75.998, -1138.61)

        -- Paralisa e trava o jogador
        Humanoid.PlatformStand = true
        RootPart.Anchored = true
        RootPart.AssemblyLinearVelocity = Vector3.zero
        RootPart.AssemblyAngularVelocity = Vector3.zero

        -- Move direto para a posi√ß√£o definida
        RootPart.CFrame = CFrame.new(fixedReturnPos)
        print("Jogador teleportado para a posi√ß√£o segura.")

        -- Fica travado por 3 segundos pra estabilizar
        task.wait(3)

        -- Libera o jogador
        RootPart.Anchored = false
        Humanoid.PlatformStand = false
        print("Jogador liberado com seguran√ßa.")
    end
})


Tab2:AddButton({
    Name = "Ban - House Kill v2",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Backpack = Player.Backpack
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Houses = game.Workspace:FindFirstChild("001_Lots")
        local OldPos = RootPart.CFrame
        local Angles = 0
        local YRotation = 0
        local Vehicles = Workspace.Vehicles
        local Pos

        -- Function:
        function Check()
            return Player and Character and Humanoid and RootPart and Vehicles
        end

        -- Main:
        if not getgenv().Target then return end
        if Check() then
            local House = Houses:FindFirstChild(Player.Name.."House")
            if not House then
                local EHouse
                for _, Lot in pairs(Houses:GetChildren()) do
                    if Lot.Name == "For Sale" then
                        for _, num in pairs(Lot:GetDescendants()) do
                            if num:IsA("NumberValue") and num.Name == "Number" and num.Value < 25 and num.Value > 10 then
                                EHouse = Lot
                                break
                            end
                        end
                    end
                end

                local BuyDetector = EHouse:FindFirstChild("BuyHouse")
                Pos = BuyDetector.Position
                if BuyDetector and BuyDetector:IsA("BasePart") then
                    RootPart.CFrame = BuyDetector.CFrame + Vector3.new(0,-6,0)
                    task.wait(.5)
                    local ClickDetector = BuyDetector:FindFirstChild("ClickDetector")
                    if ClickDetector then
                        fireclickdetector(ClickDetector)
                    end
                end
            end

            task.wait(0.5)
            local PreHouse = Houses:FindFirstChild(Player.Name .. "House")
            if PreHouse then
                task.wait(0.5)
                local Number
                for _, x in pairs(PreHouse:GetDescendants()) do
                    if x.Name == "Number" and x:IsA("NumberValue") then
                        Number = x
                    end
                end
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Gettin1gHous1e"):FireServer("PickingCustomHouse", "052_House", Number.Value)
            end

            task.wait(0.5)
            local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            if not PCar then
                if Check() then
                    RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                    task.wait(0.5)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                    task.wait(0.5)
                    PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                    task.wait(0.5)
                    local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                    if Seat then
                        repeat task.wait()
                            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                        until Humanoid.Sit
                    end
                end
            end

            task.wait(0.5)
            PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            if PCar then
                if not Humanoid.Sit then
                    local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                    if Seat then
                        repeat task.wait()
                            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                        until Humanoid.Sit
                    end
                end

                local Target = game.Players:FindFirstChild(getgenv().Target)
                local TargetC = Target and Target.Character
                local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

                if TargetC and TargetH and TargetRP then
                    if not TargetH.Sit then
                        while not TargetH.Sit do
                            task.wait()
                            local Fling = function(alvo, pos, angulo)
                                PCar:SetPrimaryPartCFrame(CFrame.new(alvo.Position) * pos * angulo)
                            end
                            
                            -- Aumentando a rota√ß√£o progressivamente
                            Angles = Angles + 100
                            YRotation = YRotation + 5000  -- Adicionando rota√ß√£o no eixo Y

                            local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

                            Fling(TargetRP, CFrame.new(0, 1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                            Fling(TargetRP, CFrame.new(0, -1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                            Fling(TargetRP, CFrame.new(2.25, 1.5, -2.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                            Fling(TargetRP, CFrame.new(-2.25, -1.5, 2.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                        end

                        task.wait(0.2)
                        local House = Houses:FindFirstChild(Player.Name.."House")
                        PCar:SetPrimaryPartCFrame(CFrame.new(House.HouseSpawnPosition.Position))
                        task.wait(0.2)
                        local Region = Region3.new(RootPart.Position - Vector3.new(30,30,30), RootPart.Position + Vector3.new(30,30,30))
                        local Parts = workspace:FindPartsInRegion3(Region, RootPart, math.huge)

                        for _, v in pairs(Parts) do
                            if v.Name == "HumanoidRootPart" then
                                local BannedPlayer = game:GetService("Players"):FindFirstChild(v.Parent.Name)
                                local args = { "BanPlayerFromHouse", BannedPlayer, v.Parent }
                                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))

                                local argsDelete = { "DeleteAllVehicles" }
                                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer(unpack(argsDelete))
                            end
                        end
                    end
                end
            end
        end
    end
})

Tab2:AddButton({
    Name = "Car - Kill",
    Callback = function()
        local Target = getgenv().Target
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame

        if not Target or not Humanoid then return end

        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if not PCar then
            if RootPart and Target then 
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                task.wait(0.5)
                local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat task.wait()
                        RootPart.CFrame = Seat.CFrame
                    until Humanoid.Sit
                end
            end
        end

        task.wait(0.5)
        PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if PCar and not Humanoid.Sit then
            local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
            if Seat then
                repeat task.wait()
                    RootPart.CFrame = Seat.CFrame
                until Humanoid.Sit
            end
        end

        local TargetPlayer = game.Players:FindFirstChild(getgenv().Target)
        if TargetPlayer then
            local TargetC = TargetPlayer.Character
            local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
            local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

            if TargetC and TargetH and TargetRP then
                if not TargetH.Sit then
                    local Angles = 0
                    local YRotation = 0

                    while not TargetH.Sit do
                        task.wait()

                        -- Mantendo a rota√ß√£o alinhada com a l√≥gica do "Ban - House"
                        Angles = Angles + 100
                        YRotation = YRotation + 5000
                        local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

                        -- Fun√ß√£o para movimentar o carro e alinhar o ataque
                        local kill = function(alvo, pos)
                            local newPosition = alvo.Position + pos + (TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.05)
                            local newCFrame = CFrame.new(newPosition) * Rotation
                            PCar:SetPrimaryPartCFrame(newCFrame)
                        end

                        -- Movimentos do carro ao redor do jogador alvo
                        kill(TargetRP, Vector3.new(0, 1, 0))
                        kill(TargetRP, Vector3.new(0, -2.25, 5))
                        kill(TargetRP, Vector3.new(0, 2.25, 0.25))
                        kill(TargetRP, Vector3.new(-2.25, -1.5, 2.25))
                        kill(TargetRP, Vector3.new(0, 1.5, 0))
                        kill(TargetRP, Vector3.new(0, -1.5, 0))
                    end

                    -- Movimenta o carro para longe ao final
                    task.wait(0.1)
                    PCar:SetPrimaryPartCFrame(CFrame.new(0, -470, 0))
                    task.wait(0.2)

                    -- Finaliza√ß√£o
                    Humanoid.Sit = false
                    task.wait(0.1)
                    RootPart.CFrame = OldPos
                end
            end
        end
    end
})


local function bringPlayer()
    local Target = getgenv().Target
    local Player = game.Players.LocalPlayer
    local Character = Player.Character
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Vehicles = game.Workspace:FindFirstChild("Vehicles")
    local OldPos = RootPart.CFrame -- Guardar a posi√ß√£o original do jogador

    if not Target or not Humanoid then return end

    -- Verificar e spawnar o carro se necess√°rio
    local PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
    if not PCar then
        if RootPart and Target then
            RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61) -- Teleporte inicial
            task.wait(0.5)
            game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
            task.wait(0.5)
            PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
            task.wait(0.5)
            local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
            if Seat then
                repeat task.wait()
                    RootPart.CFrame = Seat.CFrame
                until Humanoid.Sit
            end
        end
    end

    -- Repetir processo se o carro j√° foi criado
    task.wait(0.5)
    PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
    if PCar and not Humanoid.Sit then
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    -- Encontrar o alvo
    local TargetPlayer = game.Players:FindFirstChild(getgenv().Target)
    local TargetC = TargetPlayer and TargetPlayer.Character
    local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
    local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

    -- Teletransportar e fazer o "bring" no alvo
    if TargetC and TargetH and TargetRP then
        if not TargetH.Sit then
            local Angles = 0
            local YRotation = 0

            while not TargetH.Sit do
                task.wait()

                -- Mantendo a rota√ß√£o alinhada com a l√≥gica
                Angles = Angles + 100
                YRotation = YRotation + 5000
                local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

                -- Fun√ß√£o para movimentar o carro e alinhar o ataque
                local bring = function(alvo, pos)
                    local newPosition = alvo.Position + pos + (TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.05)
                    local newCFrame = CFrame.new(newPosition) * Rotation
                    PCar:SetPrimaryPartCFrame(newCFrame)
                end

                -- Movimentos do carro ao redor do jogador alvo
                bring(TargetRP, Vector3.new(0, 1, 0))
                bring(TargetRP, Vector3.new(0, -2.25, 5))
                bring(TargetRP, Vector3.new(0, 2.25, 0.25))
                bring(TargetRP, Vector3.new(-2.25, -1.5, 2.25))
                bring(TargetRP, Vector3.new(0, 1.5, 0))
                bring(TargetRP, Vector3.new(0, -1.5, 0))
            end

            -- Quando o alvo sentar, teleportar de volta para a posi√ß√£o antiga
            task.wait(0.1)
            PCar:SetPrimaryPartCFrame(OldPos) -- Aqui o carro vai para a sua posi√ß√£o antiga (OldPos)
            task.wait(0.2)
            Humanoid.Sit = false
            task.wait(0.1)

            -- Executar a fun√ß√£o DeleteAllVehicles ap√≥s 0.5 segundos
            task.wait(0.1)
            game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
        end
    end
end

-- Adicionando o bot√£o
Tab2:AddButton({
    Name = " Car - Bring",
    Callback = function()
        bringPlayer()
    end
})

local Section = Tab2:AddSection({"<Combat All AreaüíÄ-"})

Tab2:AddButton({
    Name = "Press! Bus - Fling All",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart and RootPart.CFrame

        if not Humanoid or not RootPart then return end

        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if not PCar then
            RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
            task.wait(0.5)
            local Remote = game.ReplicatedStorage:FindFirstChild("RE") and game.ReplicatedStorage.RE:FindFirstChild("1Ca1r")
            if Remote then Remote:FireServer("PickingCar", "SchoolBus") end
            task.wait(0.5)
            PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        end

        local timeout = 5
        while timeout > 0 and not PCar do
            task.wait(0.25)
            PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            timeout -= 0.25
        end
        if not PCar then return end

        task.wait(0.5)
        if PCar and not Humanoid.Sit then
            local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
            if Seat then
                repeat task.wait()
                    RootPart.CFrame = Seat.CFrame
                until Humanoid.Sit
            end
        end

        -- Aplica BodyVelocity no carro
        for _, part in ipairs(PCar:GetDescendants()) do
            if part:IsA("BasePart") then
                local bv = Instance.new("BodyVelocity")
                bv.Velocity = Vector3.new(1e9, 1e9, 1e9)
                bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bv.P = 500
                bv.Parent = part
            end
        end

        -- Loop cont√≠nuo para aplicar o fling em todos os jogadores
        task.spawn(function()
            local Angles = 0
            local YRotation = 0

            while PCar.Parent do
                for _, target in ipairs(game.Players:GetPlayers()) do
                    if target ~= Player then
                        local TargetC = target.Character
                        local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
                        local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

                        if TargetC and TargetH and TargetRP then
                            -- Cria for√ßas para fling
                            local attachment = Instance.new("Attachment", TargetRP)
                            local force = Instance.new("BodyVelocity")
                            force.Velocity = Vector3.new(1e9, 1e9, 1e9)
                            force.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                            force.P = 500
                            force.Parent = attachment

                            local startTime = tick()
                            while tick() - startTime < 2 and TargetRP.Parent and PCar.Parent do
                                task.wait()
                                Angles += 100
                                YRotation += 5000
                                local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

                                local function flingAttack(offset)
                                    local newPos = TargetRP.Position + offset + (TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.1)
                                    local newCF = CFrame.new(newPos) * Rotation
                                    PCar:SetPrimaryPartCFrame(newCF)
                                end

                                flingAttack(Vector3.new(0, 1, 0))
                                flingAttack(Vector3.new(0, -2.25, 5))
                                flingAttack(Vector3.new(0, 2.25, 0.25))
                                flingAttack(Vector3.new(-2.25, -1.5, 2.25))
                                flingAttack(Vector3.new(0, 1.5, 0))
                                flingAttack(Vector3.new(0, -1.5, 0))
                            end

                            -- Limpa for√ßas ao trocar de alvo
                            attachment:Destroy()
                            force:Destroy()
                        end
                    end
                end
            end
        end)

        -- Cleanup final quando ve√≠culo for removido
        repeat task.wait() until not PCar or not PCar.Parent
        Humanoid.Sit = false
        task.wait(0.1)
        if OldPos then RootPart.CFrame = OldPos end
    end
})

-- Servi√ßos
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Jogador local e caminho da bola
local localPlayer = Players.LocalPlayer
local BALL_PATH = "WorkspaceCom/001_SoccerBalls/Soccer" .. localPlayer.Name

-- Vari√°veis globais
getgenv().Target = nil
local ball, connection
local isFlinging = false  -- Controla se o Fling Ball est√° ativo

-- Remove qualquer for√ßa existente na bola
local function clearForces(targetBall)
	for _, obj in ipairs(targetBall:GetChildren()) do
		if obj:IsA("BodyForce") or obj:IsA("BodyVelocity") or obj:IsA("BodyPosition") then
			obj:Destroy()
		end
	end
end

-- Ignora colis√£o entre a bola e o personagem
local function ignorePlayerCollision(targetBall, targetCharacter)
	for _, part in ipairs(targetCharacter:GetDescendants()) do
		if part:IsA("BasePart") then
			local constraint = Instance.new("NoCollisionConstraint")
			constraint.Part0 = targetBall
			constraint.Part1 = part
			constraint.Parent = targetBall
		end
	end
end

-- Aplica for√ßa extrema na bola
local function applyFlingForces(targetBall)
	clearForces(targetBall)

	local bodyForce = Instance.new("BodyForce")
	bodyForce.Force = Vector3.new(5e7, 5e7, 5e7)
	bodyForce.Parent = targetBall

	local bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.Velocity = Vector3.new(9e6, 9e6, 9e6)
	bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bodyVelocity.P = 4e7
	bodyVelocity.Parent = targetBall
end

-- Configura a bola para seguir o alvo e causar fling
function setupBall()
	local targetName = getgenv().Target
	if not targetName then return end

	local targetPlayer = Players:FindFirstChild(targetName)
	if not targetPlayer then return end

	local character = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
	local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
	if not torso then return end

	local success, foundBall = pcall(function()
		local obj = workspace
		for _, part in ipairs(BALL_PATH:split("/")) do
			obj = obj:WaitForChild(part, 5)
		end
		return obj
	end)

	if not success or not foundBall then return end

	ball = foundBall
	ball.Anchored = false
	ball.CanCollide = true
	ball.Massless = false

	clearForces(ball)
	ignorePlayerCollision(ball, character)
	applyFlingForces(ball)

	if connection then connection:Disconnect() end

	local toggle = true
	connection = RunService.Heartbeat:Connect(function()
    if not ball or not torso then
        connection:Disconnect()
        return
    end
    bodyPosition.Position = torso.Position + Vector3.new(0, 1, 0)
end)

	targetPlayer.CharacterAdded:Connect(function()
		task.wait(1)
		setupBall()
	end)
end

-- Ciclo autom√°tico de fling em todos os jogadores
local function startFlingBallAll()
	isFlinging = true
	while isFlinging do
		local allPlayers = Players:GetPlayers()
		for _, player in ipairs(allPlayers) do
			if player ~= localPlayer then
				getgenv().Target = player.Name
				setupBall()
				task.wait(3)
			end
		end
	end
end

-- Bot√£o que ativa o Fling Ball em todos os jogadores
Tab2:AddButton({
	Name = "Fling Ball All",
	Callback = function()
		if not isFlinging then
			startFlingBallAll()
		else
			warn("O Fling Ball j√° est√° ativo em todos os jogadores.")
		end
	end
})

Tab2:AddButton({
    Name = "Fling Bus - All",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")

        -- Lista de jogadores na whitelist
        local Whitelist = {
            ["kauxz016"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        if not Humanoid or not RootPart then
            warn("Jogador sem Humanoid/RootPart")
            return
        end

        -- Fun√ß√£o para spawnar o barco
        local function spawnBoat()
            RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
            task.wait(0.5)
            game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
            task.wait(1)
            return Vehicles:FindFirstChild(Player.Name.."Car")
        end

        -- Garante que o barco foi spawnado
        local PCar = Vehicles:FindFirstChild(Player.Name.."Car") or spawnBoat()
        if not PCar then
            warn("Falha ao spawnar o barco")
            return
        end

        -- Aguarda o assento do barco
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if not Seat then
            warn("Nenhum assento encontrado no barco")
            return
        end

        -- Tenta sentar no barco
        repeat 
            task.wait()
            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
        until Humanoid.Sit

        -- Criando e adicionando o SpinGyro no barco
        local SpinGyro = Instance.new("BodyGyro")
        SpinGyro.Parent = PCar.PrimaryPart
        SpinGyro.MaxTorque = Vector3.new(1e12, 1e12, 1e12) -- Torque maior para maior rota√ß√£o
        SpinGyro.P = 1e12 -- Pot√™ncia aumentada para rota√ß√£o mais r√°pida
        SpinGyro.CFrame = PCar.PrimaryPart.CFrame

        print("SpinGyro ativado no barco! Rota√ß√£o centr√≠fuga aplicada!")

        -- Fun√ß√£o para realizar o fling em um alvo espec√≠fico
        local function flingTarget(TargetPlayer)
            local TargetC = TargetPlayer.Character
            local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
            local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

            if not TargetRP or not TargetH then
                warn("Alvo sem Humanoid/RootPart")
                return
            end

            local angle = 0
            local radius = 5
            local speed = 0.1
            local expansionRate = 0.2

            -- Loop de 3 segundos para o fling no jogador atual
            local startTime = tick()
            while tick() - startTime < 3 and PCar and PCar.Parent do
                task.wait(0.1)

                local offsetX = math.cos(angle) * radius
                local offsetZ = math.sin(angle) * radius
                local moveTo = TargetRP.Position + Vector3.new(offsetX, 0, offsetZ)

                PCar:SetPrimaryPartCFrame(CFrame.new(moveTo) * CFrame.Angles(0, math.rad(180), 0))

                angle = angle + speed
                radius = math.max(radius - expansionRate, 1)

                if (PCar.PrimaryPart.Position - TargetRP.Position).Magnitude < 3 then
                    speed = speed + 0.2
                    expansionRate = expansionRate + 0.1
                end
            end
        end

        -- Loop para alternar entre os jogadores
        task.spawn(function()
            while PCar and PCar.Parent do
                for _, TargetPlayer in pairs(game.Players:GetPlayers()) do
                    if TargetPlayer ~= Player and not Whitelist[TargetPlayer.Name] then
                        flingTarget(TargetPlayer)
                    end
                end
            end
        end)
    end
})

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Backpack = Player:FindFirstChild("Backpack")
local AllBool = false

getgenv().Target = nil -- Alvo global
local forceActive = false -- Controla se a for√ßa est√° ativa
local BV -- Vari√°vel para armazenar a BodyVelocity

local function GetPlayer(Name)
    Name = Name:lower()
    for _, x in next, Players:GetPlayers() do
        if x ~= Player then
            if x.Name:lower():match("^" .. Name) or x.DisplayName:lower():match("^" .. Name) then
                return x
            end
        end
    end
    return nil
end

local function EquipCouch()
    if Backpack then
        local Couch = Backpack:FindFirstChild("Couch")
        if Couch then
            Player.Character.Humanoid:EquipTool(Couch)
        end
    end
end

local function UnequipCouch()
    -- N√£o vamos permitir que o Couch seja desequipado
end

local function SkidFling(TargetPlayer)
    if not TargetPlayer then
        return
    end

    EquipCouch() -- Equipa o item Couch antes de iniciar o fling

    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    local TRootPart = TCharacter and TCharacter:FindFirstChild("HumanoidRootPart")

    if not Character or not Humanoid or not RootPart or not TCharacter or not TRootPart then
        return
    end

    if RootPart.Velocity.Magnitude < 50 then
        getgenv().OldPos = RootPart.CFrame
    end

    if TCharacter:FindFirstChildWhichIsA("Seat") then
        UnequipCouch() -- Se o alvo estiver sentado, desequipa o Couch
        return
    end

    local function FPos(BasePart, Pos, Ang)
        RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
        Character:SetPrimaryPartCFrame(RootPart.CFrame)
        RootPart.Velocity = Vector3.new(1e19, 1e19, 1e19)
    end

    local function SFBasePart(BasePart)
        local StartTime = tick()
        local Angle = 0

        repeat
            Angle = Angle + 100

            local THumanoid = TargetPlayer.Character:FindFirstChildOfClass("Humanoid")
            local TRootPart = TCharacter and TCharacter:FindFirstChild("HumanoidRootPart")

            if THumanoid then
                if TCharacter:FindFirstChildWhichIsA("Seat") then
                    UnequipCouch() -- Se o alvo sentar, desequipa o Couch
                    return
                end

                FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
            else
                -- Comportamento alternativo se o humanoide n√£o for encontrado
                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                task.wait()
            end
        until BasePart.Parent ~= TargetPlayer.Character or Humanoid.Health <= 0 or tick() > StartTime + 2 or TCharacter:FindFirstChildWhichIsA("Seat")
    end

    workspace.FallenPartsDestroyHeight = -math.huge

    -- Configura a for√ßa (BodyVelocity) com "um googolplex de for√ßa" (simbolicamente math.huge)
    BV = Instance.new("BodyVelocity")
    BV.Parent = RootPart
    BV.Velocity = Vector3.new(1e12, 1e12, 1e12)
    BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge) -- M√°xima for√ßa poss√≠vel no Roblox (equivalente a "infinito")

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    SFBasePart(TRootPart)

    -- Deixa a for√ßa ativa at√© o final
    forceActive = true

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)

    RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
    Humanoid.PlatformStand = true

    task.wait(1)
    Humanoid.PlatformStand = false

    -- Remove a for√ßa apenas no final da fun√ß√£o
    if BV then
        BV:Destroy()
    end
end

local function onDeath()
    -- Interrompe o Fling e a for√ßa se o jogador morrer
    forceActive = false
    if BV then
        BV:Destroy() -- Remove a BodyVelocity
    end
end

Player.Character:WaitForChild("Humanoid").Died:Connect(onDeath)

Tab2:AddButton({
    Name = "Fast - Fling All",
    Callback = function()
        local players = Players:GetPlayers()
        local playerIndex = 1

        local function FlingNextPlayer()
            if playerIndex <= #players then
                local TargetPlayer = players[playerIndex]

                if TargetPlayer == Player then
                    playerIndex = playerIndex + 1
                    return FlingNextPlayer()
                end

                -- Pede o item Couch
                local args = {
                    [1] = "PickingTools",
                    [2] = "Couch"
                }

                local remoteFunction = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Too1l")
                if remoteFunction then
                    remoteFunction:InvokeServer(unpack(args))
                    task.wait(0.2)
                end

                EquipCouch()
                task.wait(0.1)

                SkidFling(TargetPlayer)
                UnequipCouch()
                task.wait(0.2)

                playerIndex = playerIndex + 1
                FlingNextPlayer()
            end
        end

        FlingNextPlayer()
    end
})

Tab2:AddButton({
    Name = "House Kill - All",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Backpack = Player.Backpack
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Houses = game.Workspace:FindFirstChild("001_Lots")
        local Vehicles = Workspace.Vehicles

        -- Lista atualizada de nomes de usu√°rios na whitelist
        local Whitelist = {
            ["kauxz016"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        function Check()
            return Player and Character and Humanoid and RootPart and Vehicles
        end

        local function SpawnCar()
            if Check() then
                local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                if not PCar then
                    RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                    task.wait(0.5)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                    task.wait(0.5)
                    PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                    task.wait(0.5)
                    local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                    if Seat then
                        repeat task.wait()
                            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                        until Humanoid.Sit
                    end
                end
            end
        end

        if Check() then
            for _, Target in pairs(game.Players:GetPlayers()) do
                if Target ~= Player and Target.Character then
                    -- Verifica se o nome do jogador est√° na whitelist
                    if not Whitelist[Target.Name] then
                        local TargetC = Target.Character
                        local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                        local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                        if TargetH and TargetRP then
                            SpawnCar()

                            if not TargetH.Sit then
                                local Angles = 0 -- Inicializa a rota√ß√£o
                                local startTime = os.clock() -- Marca o tempo de in√≠cio
                                local timeLimit = 5 -- Limite de tempo em segundos

                                while not TargetH.Sit do
                                    task.wait()
                                    -- Verifica se o tempo limite foi excedido
                                    if os.clock() - startTime > timeLimit then
                                        break -- Sair do loop e ir para o pr√≥ximo alvo
                                    end

                                    local Fling = function(alvo, pos, angulo)
                                        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                                        if PCar then
                                            PCar:SetPrimaryPartCFrame(CFrame.new(alvo.Position) * pos * angulo)
                                        end
                                    end

                                    -- Aumentando a rota√ß√£o progressivamente
                                    Angles = Angles + 100
                                    local Rotation = CFrame.Angles(0, math.rad(Angles), 0) -- Mant√©m a rota√ß√£o apenas no eixo Y

                                    Fling(TargetRP, CFrame.new(0, 1, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                                    Fling(TargetRP, CFrame.new(0, -1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                                    Fling(TargetRP, CFrame.new(2.25, 1.5, -2.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                                    Fling(TargetRP, CFrame.new(-2.25, -1.5, 2.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                                end

                                task.wait(0.2)
                                local House = Houses:FindFirstChild(Player.Name.."House")
                                local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                                if PCar then
                                    PCar:SetPrimaryPartCFrame(CFrame.new(House.HouseSpawnPosition.Position))
                                end
                                task.wait(0.2)
                                local pedro = Region3.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position - Vector3.new(30, 30, 30), game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(30, 30, 30))

                                local a = workspace:FindPartsInRegion3(pedro, game.Players.LocalPlayer.Character.HumanoidRootPart, math.huge)

                                for i, v in pairs(a) do
                                    if v.Name == "HumanoidRootPart" then
                                        local b = game:GetService("Players"):FindFirstChild(v.Parent.Name)
                                        local args = {
                                            [1] = "BanPlayerFromHouse",
                                            [2] = b,
                                            [3] = v.Parent
                                        }

                                        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))

                                        local args = {
                                            [1] = "DeleteAllVehicles"
                                        }
                                        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer(unpack(args))
                                    end
                                end
                            end
                        end
                    end
                end
                task.wait(0.2)
            end
        end
    end
})

Tab2:AddButton({
    Name = "Car Bring - All",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame  -- Armazenar a posi√ß√£o original do jogador

        if not Humanoid or not RootPart then return end

        -- Lista de prote√ß√£o atualizada com os nomes de usu√°rio
        local ProtectedList = {
            ["kauxz016"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        local PlayersList = {} -- Lista de jogadores a serem processados
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= Player and not ProtectedList[p.Name] then
                table.insert(PlayersList, p)
            end
        end

        local function ProcessPlayer(TargetPlayer)
            local PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
            if not PCar then
                -- Teletransporta o jogador para uma posi√ß√£o inicial antes de pegar o carro
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
                local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat
                        task.wait()
                        RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                    until Humanoid.Sit
                end
            end

            local TargetC = TargetPlayer.Character
            if TargetC then
                local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                if TargetH and TargetRP then
                    local startTime = os.clock() -- Marca o tempo de in√≠cio
                    local timeLimit = 3 -- Limite de tempo de 3 segundos

                    while not TargetH.Sit do
                        task.wait()

                        -- Verifica se o tempo limite foi excedido
                        if os.clock() - startTime > timeLimit then
                            break -- Sair do loop e ir para o pr√≥ximo alvo
                        end

                        -- Rota√ß√£o aleat√≥ria ao redor do jogador
                        local randomX = math.random(-360, 360)
                        local randomY = math.random(-360, 360)
                        local randomZ = math.random(-360, 360)

                        -- Fun√ß√£o para movimentar o carro
                        local moveCar = function(alvo, offset, rotation)
                            local newPosition = alvo.Position + offset
                            local newCFrame = CFrame.new(newPosition) * rotation
                            PCar:SetPrimaryPartCFrame(newCFrame)
                        end

                        -- Movimentos do carro ao redor do jogador alvo
                        moveCar(TargetRP, Vector3.new(0, 1, 0), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, -2.25, 5), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, 2.25, 0.25), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                    end

                    -- Teleporte para a posi√ß√£o original
                    task.wait(0.1)
                    PCar:SetPrimaryPartCFrame(OldPos)  -- Usando a posi√ß√£o original do jogador

                    -- Espera e apaga o carro
                    task.wait(0.6)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
                    task.wait(0.2)
                    Humanoid.Sit = false
                    RootPart.CFrame = OldPos  -- Retorna para a posi√ß√£o original do jogador
                end
            end
        end

        -- Processa cada jogador da lista
        for _, TargetPlayer in ipairs(PlayersList) do
            ProcessPlayer(TargetPlayer)
        end
    end
})

Tab2:AddButton({
    Name = "Car Kill - All",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame

        if not Humanoid or not RootPart then return end

        -- Lista de prote√ß√£o atualizada com os nomes de usu√°rio
        local ProtectedList = {
            ["kauxz016"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        local PlayersList = {} -- Lista de jogadores a serem processados
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= Player and not ProtectedList[p.Name] then
                table.insert(PlayersList, p)
            end
        end

        local function ProcessPlayer(TargetPlayer)
            local PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
            if not PCar then
                -- Teletransporta o jogador para uma posi√ß√£o inicial antes de pegar o carro
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
                local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat
                        task.wait()
                        RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                    until Humanoid.Sit
                end
            end

            local TargetC = TargetPlayer.Character
            if TargetC then
                local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                if TargetH and TargetRP then
                    local startTime = os.clock() -- Marca o tempo de in√≠cio
                    local timeLimit = 3 -- Limite de tempo de 3 segundos

                    while not TargetH.Sit do
                        task.wait()

                        -- Verifica se o tempo limite foi excedido
                        if os.clock() - startTime > timeLimit then
                            break -- Sair do loop e ir para o pr√≥ximo alvo
                        end

                        -- Rota√ß√£o aleat√≥ria ao redor do jogador
                        local randomX = math.random(-1000, 1000)
                        local randomY = math.random(-1000, 1000)
                        local randomZ = math.random(-1000, 1000)

                        -- Fun√ß√£o para movimentar o carro
                        local moveCar = function(alvo, offset, rotation)
                            local newPosition = alvo.Position + offset
                            local newCFrame = CFrame.new(newPosition) * rotation
                            PCar:SetPrimaryPartCFrame(newCFrame)
                        end

                        -- Movimentos do carro ao redor do jogador alvo
                        moveCar(TargetRP, Vector3.new(0, 1, 0), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, -2.25, 5), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, 2.25, 0.25), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                    end

                    -- Teleporte para a coordenada final
                    task.wait(0.1)
                    PCar:SetPrimaryPartCFrame(CFrame.new(0, -600, 0))

                    -- Espera e apaga o carro
                    task.wait(0.6)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
                    task.wait(0.2)
                    Humanoid.Sit = false
                    RootPart.CFrame = OldPos
                end
            end
        end

        -- Processa cada jogador da lista
        for _, TargetPlayer in ipairs(PlayersList) do
            ProcessPlayer(TargetPlayer)
        end
    end
})


local Tab3 = Window:MakeTab({"House", "rbxassetid://10723407389"})

local Section = Tab3:AddSection({"Aba House"})

-- Se√ß√£o: Funcionalidades de Casa
local Section = Tab3:AddSection({"<Funcionalidades de Casa>"})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local selectedValue = nil

-- Cria√ß√£o da dropdown com n√∫meros de 1 a 37
local Dropdown = Tab3:AddDropdown({
    Name = "Selecione um N√∫mero De Casa",
    Options = {
        "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", 
        "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", 
        "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", 
        "31", "32", "33", "34", "35", "36", "37"
    },
    Default = {"1"},  -- Valor padr√£o
    MultSelect = false,
    Callback = function(Value)
        selectedValue = tonumber(Value)  -- Converte a sele√ß√£o para n√∫mero
    end
})

-- Bot√£o para disparar os remotes com base no n√∫mero selecionado
Tab3:AddButton({
    Name = "Lock House New",
    Callback = function()
        if not selectedValue then
            warn("Nenhuma casa selecionada.")
            return
        end

        RunService.Heartbeat:Wait()

        -- Envia PickingCustomHouse
        local args1 = {
            [1] = "PickingCustomHouse",
            [2] = "061_House",
            [3] = selectedValue
        }
        ReplicatedStorage.RE:FindFirstChild("1Gettin1gHous1e"):FireServer(unpack(args1))

        -- Ap√≥s 0.02 segundos, envia PlayerSellHouse
        task.delay(0.02, function()
            local args2 = {
                [1] = "PlayerSellHouse"
            }
            ReplicatedStorage.RE:FindFirstChild("1Player1sHous1eChoic1e"):FireServer(unpack(args2))
        end)
    end
})


local Paragraph = Tab3:AddParagraph({"Permiss√£o De Casa", "House Perm"})

-- Se√ß√£o: Permiss√µes e Teleporte
local Section = Tab3:AddSection({"<Permiss√µes e Teleporte>"})

local Players = game:GetService("Players")  
local LocalPlayer = Players.LocalPlayer  
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Houses = workspace["001_Lots"]

if not _G.ShnmaxCharacter then
  _G.ShnmaxCharacter = LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
  end)
end

local List_House_value = nil

-- Dropdown para listar casas
local List_House = Tab3:AddDropdown({
  Name = "Lista de casas",
  Options = {},
  Default = {"..."},
  MultSelect = false,
  Callback = function(value)
    List_House_value = value
  end
})

-- Fun√ß√£o para atualizar a lista de casas
local function UptadeHouse()
  local Tab_Houses = {}

  for _, House in ipairs(Houses:GetChildren()) do
    if House.Name ~= "For Sale" and House:IsA("Model") then
      table.insert(Tab_Houses, House.Name)
    end
  end
  
  if List_House then
    List_House:Set(Tab_Houses, true)
  end
end

UptadeHouse()

-- Bot√£o para atualizar as casas
Tab3:AddButton({
  Name = "Atualizar casas",
  Callback = function()
    UptadeHouse()
  end
})

-- Bot√£o para pegar permiss√£o da casa
Tab3:AddButton({
  Name = "Pegar permiss√£o da casa",
  Callback = function()
    local function ExtractNumberFromHouse(HouseName)
      local House_Target = Houses:FindFirstChild(HouseName)
      if House_Target and House_Target:IsA("Model") then
        local Number_Part = House_Target:FindFirstChild("Number")
        if Number_Part then
          local Number_Value = Number_Part:FindFirstChild("Number")
          if Number_Value then
            return Number_Value.Value
          end
        end
      end
    end

    local args = {
      [1] = "GivePermissionLoopToServer",
      [2] = game:GetService("Players").LocalPlayer,
      [3] = ExtractNumberFromHouse(List_House_value)
    }

    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))
  end
})

-- Bot√£o para teleportar para a casa
Tab3:AddButton({
  Name = "Teleportar para casa",
  Callback = function()
    local function TeleportToHouse(HouseName)
      local House_Target = Houses:FindFirstChild(HouseName)
      if House_Target and House_Target:IsA("Model") then
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        if RootPart then
          RootPart.CFrame = CFrame.new(House_Target.WorldPivot.Position)
        end
      end
    end

    TeleportToHouse(List_House_value)
  end
})

-- Se√ß√£o: Remo√ß√£o de Banimento
local Section = Tab3:AddSection({"<Remo√ß√£o de Banimento>"})

local function removerBannedLots()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local bannedLots = ReplicatedStorage:FindFirstChild("BannedLots")

    if bannedLots and bannedLots:IsA("Folder") then
        bannedLots:ClearAllChildren()
        bannedLots:Destroy()
    end
end

Tab3:AddButton({
    Name = "Remover Banimento Da Casa",
    Callback = removerBannedLots
})

    

local Tab4 =
Window:MakeTab({"SOUND ALL","RADIO"})

local Section = Tab4:AddSection({"SOUND ALL"})

local ReplicatedStorage = game:GetService("ReplicatedStorage")

if not _G.audio_all_delay then
  _G.audio_all_delay = 1
end

local function Audio_All_ClientSide(ID)

  local function CheckFolderAudioAll()
    local FolderAudio = workspace:FindFirstChild("Audio all client")
    if FolderAudio then
      return FolderAudio
    else
      local FolderAudio = Instance.new("Folder")
      FolderAudio.Name = "Audio all client"
      FolderAudio.Parent = workspace
      return FolderAudio
    end
  end

  local function CreateSound(ID)

    if type(ID) ~= "number" then
      print("Ensira o n√∫mero")
      return nil
    end

    local Folder_Audio = CheckFolderAudioAll()
    if Folder_Audio then
      local Sound = Instance.new("Sound")
      Sound.SoundId = "rbxassetid://" .. ID
      Sound.Volume = 1
      Sound.Looped = false
      Sound.Parent = Folder_Audio
      Sound:Play()
      task.wait(3)
      Sound:Destroy()
    end
  end

  CreateSound(ID)

end

local function Audio_All_ServerSide(ID)

  if type(ID) ~= "number" then
    print("Ensira um numero")
    return nil
  end

  local GunSoundEvent = ReplicatedStorage:FindFirstChild("1Gu1nSound1s", true)
  if GunSoundEvent then
    GunSoundEvent:FireServer(workspace, ID, 1)
  end
end

local audio_all_dropdown_value = nil

Tab4:AddSection({"Audio all atrav√©s de lista de IDS"})

local soundList = {
    {Name = "Grito Alto", ID = 5710016194},       -- Grito Alto
    {Name = "Jumpscare Horroroso", ID = 85435253347146}, -- Jumpscare Horroroso
    {Name = "√Åudio Alto", ID = 6855150757},        -- √Åudio Alto
    {Name = "Ru√≠do", ID = 120034877160791},        -- Ru√≠do
    {Name = "Jumpscare 2", ID = 110637995610528},  -- Jumpscare 2
    {Name = "Risada Da Bruxa Minecraft", ID = 116214940486087}, -- Risada Da Bruxa Minecraft
    {Name = "The Boiled One", ID = 137177653817621}, -- Boiola One Sanfona    
    {Name = "Deitei Um Ave Maria Doido", ID = 128669424001766},
    {Name = "Mandrake Detected", ID = 9068077052}, 
    {Name = "Aaaaaaaaa", ID = 80156405968805}, 
    {Name = "AAAHHHH", ID = 9084006093}, 
    {Name = "amongus", ID = 6651571134}, 
    {Name = "Sus", ID = 6701126635},     
    {Name = "Gritao AAAAAAAAA", ID = 5853668794},     
    {Name = "UHHHHH COFFCOFF", ID = 7056720271}, 
    {Name = "SUS", ID = 7153419575},     
}

local options = {}

for _, sound in ipairs(soundList) do
    table.insert(options, sound.Name)
end

Tab4:AddDropdown({
    Name = "Lista de Sons Irritantes",
    Options = options,
    Default = {},
    MultSelect = false,
    Callback = function(selectedName)
        for _, sound in ipairs(soundList) do
            if sound.Name == selectedName then
                audio_all_dropdown_value = sound.ID
                break
            end
        end
    end
})

Tab4:AddButton({
  Name = "Tocar audio",
  Callback = function()
    Audio_All_ServerSide(audio_all_dropdown_value)
    task.spawn(function()
      Audio_All_ClientSide(audio_all_dropdown_value)
    end)
  end
})

Tab4:AddToggle({
  Name = "Tocar loop",
  Default = false,
  Callback = function(value)

    getgenv().Audio_All_loop = value

    while getgenv().Audio_All_loop do
      Audio_All_ServerSide(audio_all_dropdown_value)
      task.spawn(function()
        Audio_All_ClientSide(audio_all_dropdown_value)
      end)
      task.wait(_G.audio_all_delay)
    end
  end
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local audioID = 5229833733 -- ID fixo do √°udio

local function Audio_All_ClientSide(ID)
    local function CheckFolderAudioAll()
        local FolderAudio = workspace:FindFirstChild("Audio all client")
        if not FolderAudio then
            FolderAudio = Instance.new("Folder")
            FolderAudio.Name = "Audio all client"
            FolderAudio.Parent = workspace
        end
        return FolderAudio
    end

    local function CreateSound(ID)
        if type(ID) ~= "number" then
            print("Insira um n√∫mero v√°lido!")
            return nil
        end

        local Folder_Audio = CheckFolderAudioAll()
        if Folder_Audio then
            local Sound = Instance.new("Sound")
            Sound.SoundId = "rbxassetid://" .. ID
            Sound.Volume = 1
            Sound.Looped = false
            Sound.Parent = Folder_Audio
            Sound:Play()
            task.wait(1) -- Tempo de espera antes de remover o som
            Sound:Destroy()
        end
    end

    CreateSound(ID)
end

local function Audio_All_ServerSide(ID)
    if type(ID) ~= "number" then
        print("Insira um n√∫mero v√°lido!")
        return nil
    end

    local GunSoundEvent = ReplicatedStorage:FindFirstChild("1Gu1nSound1s", true)
    if GunSoundEvent then
        GunSoundEvent:FireServer(workspace, ID, 1)
    end
end

Tab4:AddToggle({
    Name = "√Åudio Spam Estora ouvido - ‚ö†Ô∏è",
    Default = false,
    Callback = function(value)
        getgenv().Audio_All_loop_fast = value

        while getgenv().Audio_All_loop_fast do
            Audio_All_ServerSide(audioID)
            task.spawn(function()
                Audio_All_ClientSide(audioID)
            end)
            task.wait(0.00003)
        end
    end
})

local audio_all_textbox_value = nil

local function CheckNumberInString(str)
  return str:match("^%d+$") ~= nil
end

Tab4:AddSection({"Audio all atrav√©s de (voc√™ que colocar seus pr√≥prios ids)"})

Tab4:AddTextBox({
  Name = "Adicionar id",
  Default = "",
  PlaceholderText = "Digite um id v√°lido",
  ClearText = true,
  Callback = function(value)
    audio_all_textbox_value = value
  end
})

Tab4:AddButton({
  Name = "Tocar audio",
  Callback = function()
    
    local string_number = audio_all_textbox_value
    if CheckNumberInString(string_number) then
      Audio_All_ServerSide(tonumber(string_number))
      task.spawn(function()
        Audio_All_ClientSide(tonumber(string_number))
      end)
    else
      print("A string n√£o s√≥ tem n√∫mero")
    end
  end
})

Tab4:AddToggle({
  Name = "Tocar loop",
  Default = false,
  Callback = function(value)

    getgenv().Audio_All_loop2 = value
    local string_number = audio_all_textbox_value
    
    while getgenv().Audio_All_loop2 do
      if CheckNumberInString(string_number) then
        Audio_All_ServerSide(tonumber(string_number))
        task.spawn(function()
          Audio_All_ClientSide(tonumber(string_number))
        end)
      else
        print("A string n√£o s√≥ tem n√∫mero")
      end
      task.wait(_G.audio_all_delay)
    end
  end
})

local soundList = {
    {Name = "Grito Alto", ID = 5710016194},       -- Grito Alto
    {Name = "Jumpscare Horroroso", ID = 85435253347146}, -- Jumpscare Horroroso
    {Name = "√Åudio Alto", ID = 6855150757},        -- √Åudio Alto
    {Name = "Ru√≠do", ID = 120034877160791},        -- Ru√≠do
    {Name = "Jumpscare 2", ID = 110637995610528},  -- Jumpscare 2
    {Name = "Risada Da Bruxa Minecraft", ID = 116214940486087}, -- Risada Da Bruxa Minecraft
    {Name = "The Boiled One", ID = 137177653817621}, -- Boiola One Sanfona    
    {Name = "Deitei Um Ave Maria Doido", ID = 128669424001766},
    {Name = "Mandrake Detected", ID = 9068077052}, 
    {Name = "Aaaaaaaaa", ID = 80156405968805}, 
    {Name = "AAAHHHH", ID = 9084006093}, 
    {Name = "amongus", ID = 6651571134}, 
    {Name = "Sus", ID = 6701126635},     
    {Name = "Gritao AAAAAAAAA", ID = 5853668794},     
    {Name = "UHHHHH COFFCOFF", ID = 7056720271}, 
    {Name = "SUS", ID = 7153419575},     
}

local options = {}

for _, sound in ipairs(soundList) do
    table.insert(options, sound.Name)
end

-- Cria√ß√£o do Dropdown de sele√ß√£o de √°udio
Tab4:AddDropdown({
    Name = "Selecione um √Åudio Para Copiar",
    Options = options,
    Default = {},
    MultSelect = false,
    Callback = function(selectedName)
        for _, sound in ipairs(soundList) do
            if sound.Name == selectedName then
                -- Quando o √°udio for selecionado, copia o ID
                local selectedID = sound.ID
                setclipboard(tostring(selectedID))  -- Copia o ID para a √°rea de transfer√™ncia
                -- Exibe uma notifica√ß√£o na tela
                game:GetService("StarterGui"):SetCore("SendNotification", {
                    Title = "ID Copiado!",
                    Text = "ID do √°udio: " .. selectedID,
                    Duration = 5
                })
                print("ID copiado: " .. selectedID)  -- Exibe o ID no console
                break
            end
        end

local Tab5 = Window:MakeTab({"Car", "rbxassetid://10709783137"})

local Section = Tab5:AddSection({"Aba Car"})

local Section = Tab5:AddSection({"Velocidade"})

-- Vari√°vel global para armazenar a velocidade do carro
local carSpeed = 0

-- TextBox para escolher a velocidade do carro
Tab5:AddTextBox({
    Name = "Escolher Velocidade",
    Default = "Requer Premium",
    PlaceholderText = "Insira a velocidade do carro",
    ClearTextOnFocus = true,
    Callback = function(value)
        carSpeed = tonumber(value)  -- Converte o valor para n√∫mero
        if carSpeed then
            print("Velocidade configurada para:", carSpeed)  -- Mensagem de depura√ß√£o
        else
            print("Por favor, insira um valor num√©rico v√°lido.")
        end
    end
})

-- Bot√£o para aplicar a velocidade ao carro
Tab5:AddButton({
    Name = "Aplicar Velocidade",
    Callback = function()
        if carSpeed and carSpeed > 0 then
            -- Converte `carSpeed` para string conforme o novo padr√£o
            local args = {
                [1] = "PlayerGiveSpeedLower",
                [2] = carSpeed  -- Converte para string para enviar ao servidor
            }

            -- Verifica se o evento realmente existe
            local event = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r")
            if event then
                event:FireServer(unpack(args))
                print("Velocidade aplicada com sucesso:", carSpeed)
            else
                print("Erro: Evento '1Player1sCa1r' n√£o encontrado.")
            end
        else
            print("Por favor, insira uma velocidade v√°lida na TextBox antes de aplicar.")
        end
    end
})

local Section = Tab5:AddSection({"Music Box"})

-- TextBox para inserir o ID da m√∫sica
Tab5:AddTextBox({
    Name = "M√∫sica Box",
    Default = "Requer Premium",
    PlaceholderText = "Id Music", -- Alterado para PlaceholderText
    ClearTextOnFocus = true,
    Callback = function(value)
        musicId = value
        if musicId and musicId ~= "" then
            print("ID da m√∫sica configurado para:", musicId)  -- Mensagem de depura√ß√£o
        else
            print("Por favor, insira um ID de m√∫sica v√°lido.")
        end
    end
})

-- Bot√£o para ativar a m√∫sica
Tab5:AddButton({
    Name = "Ativar M√∫sica", -- Alterado para Name
    Callback = function()
        if musicId and musicId ~= "" then
            local args = {
                [1] = "PickingCarMusicText",
                [2] = musicId  -- Usar o ID de m√∫sica inserido na TextBox
            }

            -- Verifica se o evento existe e dispara o evento com o ID da m√∫sica
            local event = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r")
            if event then
                event:FireServer(unpack(args))
                print("M√∫sica ativada com ID:", musicId)
            else
                print("Erro: Evento '1Player1sCa1r' n√£o encontrado.")
            end
        else
            print("Por favor, insira um ID de m√∫sica v√°lido na TextBox.")
        end
    end
})

local Section = Tab5:AddSection({"Outros"})

local Toggle
local isActive = false -- Vari√°vel de controle do loop

Tab5:AddToggle({
    Name = "Texto Invas√£o!",
    Default = false,
    Callback = function(Value)
        isActive = Value -- Atualiza o estado do loop

        if isActive then
            -- Inicia o loop em uma corrotina
            coroutine.wrap(function()
                while isActive do
                    -- Tabela de comandos a serem executados
                    local commands = {
                        { [1] = "ReturningSemiName", [2] = "INVAS√ÉO" },
                        { [1] = "ReturningSemiName", [2] = "SOFRAM" },
                        { [1] = "ReturningSemiName", [2] = "ESCURID√ÉO" },
                        { [1] = "ReturningSemiName", [2] = "RAIVA" },
                        { [1] = "ReturningSemiName", [2] = "FRACOS" }
                    }

                    -- Executa cada comando sequencialmente
                    for _, args in ipairs(commands) do
                        if not isActive then break end -- Interrompe se o Toggle for desativado
                        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Cemeter1y"):FireServer(unpack(args))
                        wait(1) -- Aguarda 1 segundo entre os comandos (ajuste conforme necess√°rio)
                    end
                end
            end)()
        end
    end
})

-- Servi√ßos para Rainbow Car
local args = {
    [1] = "PickingCarColor",
    [2] = nil --[[Color3]]
}

-- Fun√ß√£o para mudar a cor aleatoriamente
local function getRandomColor()
    return Color3.new(math.random(), math.random(), math.random())
end

local running = false
local changingColor = false -- Nova vari√°vel para controlar a execu√ß√£o da fun√ß√£o

-- Fun√ß√£o para iniciar/parar a mudan√ßa de cor
local function changeColor()
    changingColor = true -- Define que a mudan√ßa de cor est√° em andamento
    while running do
        args[2] = getRandomColor()
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer(unpack(args))
        
        wait(1) -- intervalo de mudan√ßa de cor, ajustado para prevenir kick
    end
    changingColor = false -- Redefine quando a execu√ß√£o √© conclu√≠da
end

-- Cria√ß√£o do Toggle para Rainbow Car com a nova estrutura
local RainbowCarToggle = Tab5:AddToggle({
    Name = "Rainbow Car", -- Alterado para Name
    Default = false,
    Callback = function(Value)
        running = Value
        if running and not changingColor then
            spawn(changeColor)  -- Inicia a mudan√ßa de cor se o Toggle estiver ativo e n√£o estiver mudando
        elseif not running then
            print("Rainbow Car desativado.")
        end
    end
})

-- Fun√ß√µes auxiliares para controle do Toggle
RainbowCarToggle:Set(false) -- Define o estado inicial como "desligado"

local isRunning = false -- Vari√°vel para controlar o estado do loop

Toggle = Tab5:AddToggle({
    Name = "Loop Duke 1",
    Default = false,
    Callback = function(Value)
        if Value then
            isRunning = true -- Define como verdadeiro quando o toggle √© ativado
            while isRunning do
                local args = {
                    [1] = "Duke1"
                }
                
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer(unpack(args))
                
                wait(1) -- Espera 3 segundos antes de executar novamente
            end
        else
            isRunning = false -- Define como falso quando o toggle √© desativado
        end
    end
})

local isRunning = false -- Vari√°vel para controlar o estado do loop

Toggle = Tab5:AddToggle({
    Name = "Loop Duke 2",
    Default = false,
    Callback = function(Value)
        if Value then
            isRunning = true -- Define como verdadeiro quando o toggle √© ativado
            while isRunning do
                local args = {
                    [1] = "Duke"
                }
                
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer(unpack(args))
                
                wait(1) -- Espera 3 segundos antes de executar novamente
            end
        else
            isRunning = false -- Define como falso quando o toggle √© desativado
        end
    end
})

local isRunning = false -- Vari√°vel para controlar o estado do loop

Toggle = Tab5:AddToggle({
    Name = "Loop Fire",
    Default = false,
    Callback = function(Value)
        if Value then
            isRunning = true -- Define como verdadeiro quando o toggle √© ativado
            while isRunning do
                local args = {
                    [1] = "Fire"
                }
                
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sCa1r"):FireServer(unpack(args))
                
                wait(1) -- Espera 3 segundos antes de executar novamente
            end
        else
            isRunning = false -- Define como falso quando o toggle √© desativado
        end
    end
})
    end
})



local Tab6 = Window:MakeTab({"Avatar", "rbxassetid://10734952036"})

local Section = Tab6:AddSection({"Aba Avatar"})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remotes = ReplicatedStorage:WaitForChild("Remotes")

local Target = nil

-- Fun√ß√£o para obter os nomes dos jogadores
local function GetPlayerNames()
    local PlayerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(PlayerNames, player.Name)
    end
    return PlayerNames
end

-- Dropdown de sele√ß√£o de jogador
local Dropdown = Tab6:AddDropdown({
    Name = "Selecionar Jogador Para a C√≥pia",
    Options = GetPlayerNames(),
    Default = Target,
    Callback = function(Value)
        Target = Value
    end
})

-- Atualiza op√ß√µes do dropdown quando algu√©m entra ou sai
local function UpdateDropdown()
    Dropdown:Refresh(GetPlayerNames(), true)
end

Players.PlayerAdded:Connect(UpdateDropdown)
Players.PlayerRemoving:Connect(UpdateDropdown)

-- Bot√£o de copiar avatar
Tab6:AddButton({
    Name = "Copy Avatar",
    Callback = function()
        if not Target then return end

        local LP = Players.LocalPlayer
        local LChar = LP.Character
        local TPlayer = Players:FindFirstChild(Target)

        if TPlayer and TPlayer.Character then
            local LHumanoid = LChar and LChar:FindFirstChildOfClass("Humanoid")
            local THumanoid = TPlayer.Character:FindFirstChildOfClass("Humanoid")

            if LHumanoid and THumanoid then
                -- RESETAR LOCALPLAYER
                local LDesc = LHumanoid:GetAppliedDescription()

                -- Remover acess√≥rios, roupas e face atuais
                for _, acc in ipairs(LDesc:GetAccessories(true)) do
                    if acc.AssetId and tonumber(acc.AssetId) then
                        Remotes.Wear:InvokeServer(tonumber(acc.AssetId))
                        task.wait(0.2)
                    end
                end

                if tonumber(LDesc.Shirt) then
                    Remotes.Wear:InvokeServer(tonumber(LDesc.Shirt))
                    task.wait(0.2)
                end

                if tonumber(LDesc.Pants) then
                    Remotes.Wear:InvokeServer(tonumber(LDesc.Pants))
                    task.wait(0.2)
                end

                if tonumber(LDesc.Face) then
                    Remotes.Wear:InvokeServer(tonumber(LDesc.Face))
                    task.wait(0.2)
                end

                -- COPIAR DO JOGADOR ALVO
                local PDesc = THumanoid:GetAppliedDescription()

                -- Enviar partes do corpo
                local argsBody = {
                    [1] = {
                        [1] = PDesc.Torso,
                        [2] = PDesc.RightArm,
                        [3] = PDesc.LeftArm,
                        [4] = PDesc.RightLeg,
                        [5] = PDesc.LeftLeg,
                        [6] = PDesc.Head
                    }
                }
                Remotes.ChangeCharacterBody:InvokeServer(unpack(argsBody))
                task.wait(0.5)

                if tonumber(PDesc.Shirt) then
                    Remotes.Wear:InvokeServer(tonumber(PDesc.Shirt))
                    task.wait(0.3)
                end

                if tonumber(PDesc.Pants) then
                    Remotes.Wear:InvokeServer(tonumber(PDesc.Pants))
                    task.wait(0.3)
                end

                if tonumber(PDesc.Face) then
                    Remotes.Wear:InvokeServer(tonumber(PDesc.Face))
                    task.wait(0.3)
                end

                for _, v in ipairs(PDesc:GetAccessories(true)) do
                    if v.AssetId and tonumber(v.AssetId) then
                        Remotes.Wear:InvokeServer(tonumber(v.AssetId))
                        task.wait(0.3)
                    end
                end

                local SkinColor = TPlayer.Character:FindFirstChild("Body Colors")
                if SkinColor then
                    Remotes.ChangeBodyColor:FireServer(tostring(SkinColor.HeadColor))
                    task.wait(0.3)
                end

                if tonumber(PDesc.IdleAnimation) then
                    Remotes.Wear:InvokeServer(tonumber(PDesc.IdleAnimation))
                    task.wait(0.3)
                end

                -- Nome, bio e cor
                local Bag = TPlayer:FindFirstChild("PlayersBag")
                if Bag then
                    if Bag:FindFirstChild("RPName") and Bag.RPName.Value ~= "" then
                        Remotes.RPNameText:FireServer("RolePlayName", Bag.RPName.Value)
                        task.wait(0.3)
                    end
                    if Bag:FindFirstChild("RPBio") and Bag.RPBio.Value ~= "" then
                        Remotes.RPNameText:FireServer("RolePlayBio", Bag.RPBio.Value)
                        task.wait(0.3)
                    end
                    if Bag:FindFirstChild("RPNameColor") then
                        Remotes.RPNameColor:FireServer("PickingRPNameColor", Bag.RPNameColor.Value)
                        task.wait(0.3)
                    end
                    if Bag:FindFirstChild("RPBioColor") then
                        Remotes.RPNameColor:FireServer("PickingRPBioColor", Bag.RPBioColor.Value)
                        task.wait(0.3)
                    end
                end
            end
        end
    end
})



local Tab7 = Window:MakeTab({"Misc", "rbxassetid://10723344088"})

local Section = Tab7:AddSection({"Aba Misc"})


Tab7:AddButton({
    Name = "Boombox 100% All",
    Callback = function()
        local player = game.Players.LocalPlayer
        local playerGui = player:FindFirstChild("PlayerGui")
        if not playerGui then return end -- Verifica se o jogador tem PlayerGui

        local boombox
        local sg
        local savedID = nil  -- Vari√°vel para armazenar o ID salvo
        local listFrame = {}  -- Tabela para controlar m√∫ltiplos frames da boombox

        -- Fun√ß√£o para criar a Boombox
        local function createBoombox()
            boombox = Instance.new("Tool")
            boombox.Name = "Boombox"
            boombox.RequiresHandle = true
            boombox.Parent = player.Backpack

            local handle = Instance.new("Part")
            handle.Name = "Handle"
            handle.Size = Vector3.new(1, 1, 1)
            handle.CanCollide = false
            handle.Anchored = false
            handle.Transparency = 1
            handle.Parent = boombox

            -- Fun√ß√£o para criar a GUI de m√∫sica
            local function createGui()
                -- Verifica se j√° existe um frame da boombox
                if listFrame[player.UserId] then
                    return  -- Interrompe a cria√ß√£o da GUI se j√° existir
                end

                -- Marca que a GUI foi criada para esse jogador
                listFrame[player.UserId] = true

                sg = Instance.new("ScreenGui")
                sg.Name = "ChooseSongGui"
                sg.Parent = playerGui  

                local frame = Instance.new("Frame")
                frame.Style = "RobloxRound"
                frame.Size = UDim2.new(0.25, 0, 0.25, 0)
                frame.Position = UDim2.new((1-frame.Size.X.Scale)/2, 0, (1-frame.Size.Y.Scale)/2, 0)
                frame.Parent = sg
                frame.Draggable = true

                local text = Instance.new("TextLabel")
                text.BackgroundTransparency = 1
                text.TextStrokeTransparency = 0
                text.TextColor3 = Color3.new(1, 1, 1)
                text.Size = UDim2.new(1, 0, 0.6, 0)
                text.TextScaled = true
                text.Text = "Lay down the beat!\nPut in the ID number for a song you love that's been uploaded to ROBLOX.\nLeave it blank to stop playing music."
                text.Parent = frame

                local input = Instance.new("TextBox")
                input.BackgroundColor3 = Color3.new(0, 0, 0)
                input.BackgroundTransparency = 0.5
                input.BorderColor3 = Color3.new(1, 1, 1)
                input.TextColor3 = Color3.new(1, 1, 1)
                input.TextStrokeTransparency = 1
                input.TextScaled = true
                input.Text = savedID or "142376088"  -- Usar o ID salvo ou o padr√£o
                input.Size = UDim2.new(1, 0, 0.2, 0)
                input.Position = UDim2.new(0, 0, 0.6, 0)
                input.Parent = frame

                local button = Instance.new("TextButton")
                button.Style = "RobloxButton"
                button.Size = UDim2.new(0.75, 0, 0.2, 0)
                button.Position = UDim2.new(0.125, 0, 0.8, 0)
                button.TextColor3 = Color3.new(1, 1, 1)
                button.TextStrokeTransparency = 0
                button.Text = "Play!"
                button.TextScaled = true
                button.Parent = frame

                -- Fun√ß√£o para tocar a m√∫sica no servidor
                local function playAudioAll(ID)
                    if type(ID) ~= "number" then
                        print("Insira um n√∫mero v√°lido!")
                        return
                    end

                    local ReplicatedStorage = game:GetService("ReplicatedStorage")
                    local GunSoundEvent = ReplicatedStorage:FindFirstChild("1Gu1nSound1s", true)
                    if GunSoundEvent then
                        GunSoundEvent:FireServer(workspace, ID, 1)
                    end
                end

                -- Fun√ß√£o para tocar a m√∫sica localmente
                local function playAudioLocal(ID)
                    local sound = Instance.new("Sound")
                    sound.SoundId = "rbxassetid://" .. ID
                    sound.Volume = 1
                    sound.Looped = false
                    sound.Parent = player.Character or workspace
                    sound:Play()
                    task.wait(3)
                    sound:Destroy()
                end

                -- Fun√ß√£o do bot√£o "Play!"
                button.MouseButton1Click:Connect(function()
                    local soundID = tonumber(input.Text)
                    if soundID then
                        savedID = soundID  -- Salva o ID que foi inserido
                        playAudioAll(soundID) -- Toca para o servidor
                        playAudioLocal(soundID) -- Toca para voc√™ tamb√©m
                    else
                        print("ID inv√°lido!")
                    end

                    -- Remove a GUI instantaneamente
                    if sg then
                        sg:Destroy()
                        listFrame[player.UserId] = nil  -- Libera a GUI para futuras intera√ß√µes
                    end
                end)

            end

            -- Evento ao equipar a Boombox
            boombox.Equipped:Connect(function()
                -- Cria a GUI quando a Boombox √© equipada, se ainda n√£o existir
                if not listFrame[player.UserId] then
                    createGui()
                end

                -- Comando para equipar visualmente o Boombox no avatar
                local args = {
                    [1] = 1018548665  -- ID original
                }
                game:GetService("ReplicatedStorage").Remotes.Wear:InvokeServer(unpack(args))
            end)

            -- Evento ao desequipar a Boombox
            boombox.Unequipped:Connect(function()
                -- Remove a GUI quando o item for desequipado
                if sg then
                    sg:Destroy()
                    sg = nil
                end

                -- Comando para remover a Boombox visual do avatar
                local args = {
                    [1] = 1018548665  -- ID original
                }
                game:GetService("ReplicatedStorage").Remotes.Wear:InvokeServer(unpack(args))

                -- Libera a GUI para a cria√ß√£o de um novo frame caso o item seja re-equipado
                listFrame[player.UserId] = nil
            end)

            -- Evento para detectar se a Boombox foi deletada da mochila
            boombox.AncestryChanged:Connect(function(_, parent)
                if not parent and sg then
                    sg:Destroy()
                    sg = nil
                    listFrame[player.UserId] = nil  -- Permite criar a GUI novamente quando o item for removido
                end
            end)
        end

        -- Chama a fun√ß√£o para criar a Boombox
        createBoombox()
    end
})

Tab7:AddButton({
  Name = "Dark Blade",
  Callback = function()
    loadstring(game:HttpGet('https://pastebin.com/raw/6ctYevGX'))()
  end
})

-- Se√ß√£o: Modifica√ß√µes de Jogador
local Section = Tab7:AddSection({"<Modifica√ß√µes de Jogador>"})

Tab7:AddSlider({
   Name = "Velocidade do Jogador",
   Increase = 1,
   MinValue = 16,
   MaxValue = 888,
   Default = 16,
   Callback = function(Value)
       local player = game.Players.LocalPlayer
       local character = player.Character or player.CharacterAdded:Wait()
       local humanoid = character:FindFirstChildOfClass("Humanoid")
       
       if humanoid then
           humanoid.WalkSpeed = Value
       end
   end
})


Tab7:AddButton({
    Name = "Get Trail fe",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local OldPos = RootPart.CFrame
        
        local function freezeHumanoid(humanoid)
            humanoid.WalkSpeed = 0
            humanoid.JumpPower = 0
        end
        
        local function restoreHumanoid(humanoid)
            humanoid.WalkSpeed = 16
            humanoid.JumpPower = 50
        end
        
        local firstPosition = CFrame.new(-349, 5, 98)
        
        local PoolClick = workspace.WorkspaceCom["001_Hospital"]:FindFirstChild("PoolClick")
        
        if PoolClick and PoolClick:FindFirstChild("ClickDetector") then
            freezeHumanoid(Humanoid)
            RootPart.CFrame = firstPosition
            task.wait(1)
            RootPart.CFrame = PoolClick.CFrame
            fireclickdetector(PoolClick.ClickDetector)
            task.wait(2)
            RootPart.CFrame = OldPos
            restoreHumanoid(Humanoid)
        else
            warn("PoolClick ou ClickDetector n√£o encontrado!")
        end
    end
})


local Tab8 = Window:MakeTab({"Items", "shield"})

local Section = Tab8:AddSection({"<Lag Server>"})

local BNumber = 1000

Tab8:AddToggle({
    Name = "lag Basketball",
    Default = false,
    Callback = function(Value)
        local BasketToggleH = Value
        if BasketToggleH then
            local Player = game.Players.LocalPlayer
            local Backpack = Player.Backpack
            local Mouse = Player:GetMouse()
            local Character = Player.Character
            local Humanoid = Character:FindFirstChildOfClass("Humanoid")
            local RootPart = Character:FindFirstChild("HumanoidRootPart")
            local OldPos = RootPart.CFrame
            local Clone = workspace.WorkspaceCom["001_GiveTools"].Basketball

            for i = 1, BNumber do
                task.wait()
                RootPart.CFrame = Clone.CFrame
                fireclickdetector(Clone.ClickDetector)
            end
            task.wait()
            RootPart.CFrame = OldPos

            while BasketToggleH do
                task.wait()
                for i, v in ipairs(Character:GetChildren()) do
                    if v.Name == "Basketball" then
                        task.wait()
                        local args = {
                            [1] = Mouse.Hit.p
                        }
                        v.ClickEvent:FireServer(unpack(args))
                    end
                end
            end
        end
    end
})

Tab8:AddSlider({
    Name = "PORCENTAGEM De Basketball",
    MinValue = 1,
    MaxValue = 1000,
    Default = BNumber,
    Increase = 1,
    Callback = function(Value)
        BNumber = Value
    end
})

local cleartoolremote = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Clea1rTool1s") 
local picktoolremote = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Too1l")

-- Vari√°vel global para controlar a interrup√ß√£o do processo 
local stopProcess = false

-- Fun√ß√£o para resetar o personagem 
local function resetCharacter() 
    local player = game.Players.LocalPlayer 
    if player.Character then 
        player.Character:BreakJoints()  -- Reseta o personagem 
    end 
end

-- Fun√ß√£o para criar um tornado de PaintRollers 
local function createPaintRollerTornado(height, radius, rotationSpeed, verticalSpacing)
    -- Reinicia a vari√°vel de controle ao iniciar o processo
    stopProcess = false
    local nametools = "PaintRoller Tornado"
    local oldcframe = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame    

    -- Verifica se o personagem est√° sentado e o levanta   
    if game.Players.LocalPlayer.Character.Humanoid.Sit then       
        task.wait()       
        game.Players.LocalPlayer.Character.Humanoid.Sit = false   
    end    

    wait()   
    cleartoolremote:FireServer("ClearAllTools")    

    -- Remove a c√¢mera se existir   
    if workspace:FindFirstChild("Camera") then       
        workspace.Camera:Destroy()   
    end    

    -- Teleporta o personagem para uma posi√ß√£o segura   
    for _ = 1, 2 do       
        task.wait()       
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(999999999, -490, 999999999)   
    end    

    task.wait()   
    game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true   
    wait()    

    -- Loop de duplica√ß√£o das ferramentas   
    for i = 1, height do       
        if stopProcess then           
            game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false           
            resetCharacter()           
            return       
        end        

        -- Pega a ferramenta       
        picktoolremote:InvokeServer("PickingTools", "PaintRoller")       
        local tool = game.Players.LocalPlayer.Backpack:WaitForChild("PaintRoller")       
        tool.Parent = game.Players.LocalPlayer.Character        

        if stopProcess then           
            game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false           
            resetCharacter()           
            return       
        end        

        wait()       
        tool.Handle.Name = "H‚Å•a‚Å•n‚Å•d‚Å•l‚Å•e"       
        tool.Parent = game.Players.LocalPlayer.Backpack       
        tool.Parent = game.Players.LocalPlayer.Character        

        -- Espera at√© que a ferramenta seja removida do personagem       
        repeat           
            if workspace:FindFirstChild("Camera") then               
                workspace.Camera:Destroy()           
            end           
            wait()       
        until not game.Players.LocalPlayer.Character:FindFirstChild("PaintRoller")   
    end    

    -- Finaliza o processo   
    game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false   
    repeat wait() until not game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")   
    repeat wait() until game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")    

    -- Posicionamento dos PaintRollers em forma de tornado   
    local tools = game.Players.LocalPlayer.Backpack:GetChildren()   
    local centerPosition = Vector3.new(0, 0, 0)    

    for i = 1, #tools do       
        if tools[i]:IsA("Tool") then           
            -- C√°lculo da posi√ß√£o em espiral           
            local angle = math.rad(i * rotationSpeed)           
            local x = math.cos(angle) * radius           
            local z = math.sin(angle) * radius           
            local y = (i - 1) * verticalSpacing  -- Altura incremental            

            tools[i].Grip = CFrame.new(centerPosition + Vector3.new(x, y, z))           
            tools[i].Name = nametools       
        end   
    end    

    -- Retorna o personagem √† posi√ß√£o original   
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = oldcframe   
    wait(0.5)    

    -- Move as ferramentas para o personagem   
    for _, tool in ipairs(game.Players.LocalPlayer.Backpack:GetChildren()) do       
        if tool:IsA("Tool") and tool.Name == nametools then           
            tool.Parent = game.Players.LocalPlayer.Character       
        end   
    end
end

-- Adiciona um bot√£o para criar o tornado 
Section = Tab8:AddSection({ Name = "Tornado de PaintRollers" })

Tab8:AddButton({ Name = "Criar Tornado de PaintRollers (Altura: 100, Raio: 5)", Callback = function() 
    createPaintRollerTornado(70, 5, 20, 0.5)  -- Ajuste os par√¢metros conforme necess√°rio 
end })

Tab8:AddButton({ Name = "Parar Processo de Constru√ß√£o", Callback = function() 
    stopProcess = true 
    resetCharacter() 
end })

Tab8:AddButton({
	Name = "Mudar Anima√ß√£o do Tornado de PaintRoller",
	Callback = function()
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local backpack = player:WaitForChild("Backpack")

        -- Move todos os PaintRollers do tipo Tornado para o personagem
        for _, tool in ipairs(backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name == "PaintRoller Tornado" then
                tool.Parent = character
            end
        end

        task.wait(0.2) -- D√° tempo para mover tudo com seguran√ßa

        -- Dispara o evento CycleNextAnimation em cada um
        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name == "PaintRoller Tornado" then
                if tool:FindFirstChild("CycleNextAnimation") then
                    tool.CycleNextAnimation:FireServer()
                end
            end
        end
	end    
})

Tab8:AddButton({
	Name = "Equipar Todas as Tools",
	Callback = function()
      		local function equiptool()
  for i,v in ipairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
    if v:IsA("Tool") then
      v.Parent = game.Players.LocalPlayer.Character
    end
  end
end
equiptool()
  	end    
})


local Tab9 = Window:MakeTab({"Esp", "rbxassetid://10747382504"})

local Section = Tab9:AddSection({"Aba Esp"})

local ESPEnabled = false
local CurrentColor = Color3.fromRGB(255, 255, 255) -- Cor inicial branca
local RainbowEnabled = false

local function createESP(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end

    -- Adicionar Highlight para destacar o jogador
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight"
    highlight.Adornee = player.Character
    highlight.FillColor = CurrentColor
    highlight.FillTransparency = 0.5
    highlight.OutlineColor = Color3.fromRGB(0, 0, 0)
    highlight.OutlineTransparency = 0
    highlight.Parent = player.Character

    -- Criar BillboardGui para exibir as informa√ß√µes
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_Info"
    billboard.Adornee = player.Character:FindFirstChild("HumanoidRootPart")
    billboard.Size = UDim2.new(0, 150, 0, 50)  -- Diminuindo o tamanho da GUI
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = player.Character

    -- Nome do jogador
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 0.2, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = player.Name
    nameLabel.TextColor3 = CurrentColor
    nameLabel.TextStrokeTransparency = 0
    nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    nameLabel.TextScaled = true
    nameLabel.Font = Enum.Font.Code -- Fonte digital
    nameLabel.Parent = billboard

    -- Dist√¢ncia
    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Size = UDim2.new(1, 0, 0.2, 0)
    distanceLabel.Position = UDim2.new(0, 0, 0.2, 0)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Text = "Dist√¢ncia: Calculando..."
    distanceLabel.TextColor3 = CurrentColor
    distanceLabel.TextStrokeTransparency = 0
    distanceLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    distanceLabel.TextScaled = true
    distanceLabel.Font = Enum.Font.Code -- Fonte digital
    distanceLabel.Parent = billboard

    -- Idade da conta
    local ageLabel = Instance.new("TextLabel")
    ageLabel.Size = UDim2.new(1, 0, 0.2, 0)
    ageLabel.Position = UDim2.new(0, 0, 0.4, 0)
    ageLabel.BackgroundTransparency = 1
    ageLabel.Text = "Idade da conta: " .. player.AccountAge .. " dias"
    ageLabel.TextColor3 = CurrentColor
    ageLabel.TextStrokeTransparency = 0
    ageLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    ageLabel.TextScaled = true
    ageLabel.Font = Enum.Font.Code -- Fonte digital
    ageLabel.Parent = billboard

    -- Status de vida
    local healthLabel = Instance.new("TextLabel")
    healthLabel.Size = UDim2.new(1, 0, 0.2, 0)
    healthLabel.Position = UDim2.new(0, 0, 0.6, 0)
    healthLabel.BackgroundTransparency = 1
    healthLabel.Text = "Vida: " .. math.floor(player.Character.Humanoid.Health)
    healthLabel.TextColor3 = CurrentColor
    healthLabel.TextStrokeTransparency = 0
    healthLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    healthLabel.TextScaled = true
    healthLabel.Font = Enum.Font.Code -- Fonte digital
    healthLabel.Parent = billboard

    -- Status de sentado
    local sittingLabel = Instance.new("TextLabel")
    sittingLabel.Size = UDim2.new(1, 0, 0.2, 0)
    sittingLabel.Position = UDim2.new(0, 0, 0.8, 0)
    sittingLabel.BackgroundTransparency = 1
    sittingLabel.Text = "Sentado: N√£o"
    sittingLabel.TextColor3 = CurrentColor
    sittingLabel.TextStrokeTransparency = 0
    sittingLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    sittingLabel.TextScaled = true
    sittingLabel.Font = Enum.Font.Code -- Fonte digital
    sittingLabel.Parent = billboard

    -- Atualizar dist√¢ncia, sa√∫de e status de sentado continuamente
    task.spawn(function()
        while ESPEnabled and player.Character and player.Character:FindFirstChild("HumanoidRootPart") do
            local distance = (player.Character.HumanoidRootPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
            distanceLabel.Text = string.format("Dist√¢ncia: %.2f", distance)
            healthLabel.Text = "Vida: " .. math.floor(player.Character.Humanoid.Health)
            sittingLabel.Text = player.Character.Humanoid.Sit == true and "Sentado: Sim" or "Sentado: N√£o"

            -- Atualizar cor dinamicamente
            highlight.FillColor = CurrentColor
            nameLabel.TextColor3 = CurrentColor
            distanceLabel.TextColor3 = CurrentColor
            ageLabel.TextColor3 = CurrentColor
            healthLabel.TextColor3 = CurrentColor
            sittingLabel.TextColor3 = CurrentColor

            task.wait(0.1)
        end
    end)
end

local function toggleESP(enabled)
    ESPEnabled = enabled
    if ESPEnabled then
        for _, player in pairs(game.Players:GetPlayers()) do
            if player ~= game.Players.LocalPlayer and not player.Character:FindFirstChild("ESP_Info") then
                createESP(player)
            end
        end

        game.Players.PlayerAdded:Connect(function(player)
            if ESPEnabled then
                player.CharacterAdded:Connect(function()
                    createESP(player)
                end)
            end
        end)

        game.Players.PlayerRemoving:Connect(function(player)
            if player.Character then
                if player.Character:FindFirstChild("ESP_Info") then
                    player.Character.ESP_Info:Destroy()
                end
                if player.Character:FindFirstChild("ESP_Highlight") then
                    player.Character.ESP_Highlight:Destroy()
                end
            end
        end)
    else
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character then
                if player.Character:FindFirstChild("ESP_Info") then
                    player.Character.ESP_Info:Destroy()
                end
                if player.Character:FindFirstChild("ESP_Highlight") then
                    player.Character.ESP_Highlight:Destroy()
                end
            end
        end
    end
end

local function setESPColor(color)
    CurrentColor = color
    RainbowEnabled = false -- Desativar Rainbow ao selecionar uma cor
end

local function enableRainbow()
    RainbowEnabled = true
    task.spawn(function()
        while RainbowEnabled do
            local time = tick() * 5
            CurrentColor = Color3.fromHSV((time % 360) / 360, 1, 1)
            task.wait(0.1)
        end
    end)
end

-- Toggle para ativar/desativar ESP
Tab9:AddToggle({
    Name = "ESP",
    Default = false, -- Inicialmente desativado
    Callback = function(Value)
        toggleESP(Value)
    end
})

-- Conectar evento para reativar o ESP ap√≥s a morte
game.Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        -- Verificar se o ESP est√° ativado e recriar o ESP para o jogador
        if ESPEnabled then
            createESP(player)
        end
    end)
end)

-- Dropdown para sele√ß√£o de cor
Tab9:AddDropdown({
    Name = "Cores do ESP",
    Options = {"Azul", "Vermelho", "Verde", "Amarelo", "Roxo", "Cinza", "Preto", "Branco", "Laranja", "Rosa", "Marrom", "Rainbow"},
    Default = {"Branco"},
    Callback = function(selected)
        if selected == "Azul" then
            setESPColor(Color3.fromRGB(0, 0, 255))
        elseif selected == "Vermelho" then
            setESPColor(Color3.fromRGB(255, 0, 0))
        elseif selected == "Verde" then
            setESPColor(Color3.fromRGB(0, 255, 0))
        elseif selected == "Amarelo" then
            setESPColor(Color3.fromRGB(255, 255, 0))
        elseif selected == "Roxo" then
            setESPColor(Color3.fromRGB(128, 0, 128))
        elseif selected == "Cinza" then
            setESPColor(Color3.fromRGB(128, 128, 128))
        elseif selected == "Preto" then
            setESPColor(Color3.fromRGB(0, 0, 0))
        elseif selected == "Branco" then
            setESPColor(Color3.fromRGB(255, 255, 255))
        elseif selected == "Laranja" then
            setESPColor(Color3.fromRGB(255, 165, 0))
        elseif selected == "Rosa" then
            setESPColor(Color3.fromRGB(255, 192, 203))
        elseif selected == "Marrom" then
            setESPColor(Color3.fromRGB(139, 69, 19))
        elseif selected == "Rainbow" then
            enableRainbow()
        end
    end
})


local Tab10 = Window:MakeTab({"Scripts", "rbxassetid://10709806277"})

local Section = Tab10:AddSection({"Aba Scripts"})

Tab10:AddButton({
  Name = "Infinite Yield Matrix Hub",
  Callback = function()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/oi123-lab/Matrix-admin/refs/heads/main/Matrix%20admin.txt'))()
  end
})

Tab10:AddButton({
  Name = "Ant Lag V2",
  Callback = function()
    loadstring(game:HttpGet('https://pastebin.com/raw/ureZEHue'))()
  end
})


Tab10:AddButton({
  Name = "Shaders",
  Callback = function()
loadstring(game:HttpGet("https://pastebin.com/raw/WKVg6QPs"))()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local MaterialService = game:GetService("MaterialService")
local SoundService = game:GetService("SoundService")

local Terrain = Workspace:FindFirstChildOfClass("Terrain") or Workspace.Terrain
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

-- Configs gerais
MaterialService.Use2022Materials = true
Lighting.Brightness = 4.0

-- Limpeza de objetos d'agua
for _, obj in ipairs(Workspace:GetDescendants()) do
	if table.find({ "WaterHole", "WaterMeah", "Water" }, obj.Name) then
		obj:Destroy()
	end
end

-- Funcoes de cor
local function isColor(c, cond)
	local r, g, b = c.R, c.G, c.B
	if cond == "white" then return r > 0.8 and g > 0.8 and b > 0.8 end
	if cond == "black" then return r < 0.2 and g < 0.2 and b < 0.2 end
	if cond == "red" then return r > g * 1.3 and r > b * 1.3 end
	if cond == "blue" then return b > r * 1.3 and b > g * 1.3 end
	if cond == "yellow" then return r > 0.8 and g > 0.8 and b < 0.4 end
	if cond == "orange" then return r > 0.7 and g > 0.3 and b < 0.2 end
	if cond == "green" then return g > r * 1.2 and g > b * 1.2 end
	if cond == "purple" then return r > 0.3 and b > 0.3 and g < 0.2 end
	if cond == "pink" then return r > 0.8 and b > 0.6 and g < 0.5 end
	if cond == "brown" then return r > 0.3 and g > 0.2 and b < 0.1 end
	if cond == "gray" then
		local diff = math.abs(r - g) + math.abs(g - b) + math.abs(b - r)
		return diff < 0.08 and r > 0.2 and r < 0.8
	end
end

-- Definir material pela cor
local function getMaterialByColor(part)
	local name = part.Name:lower()
	local c = part.Color
	if name:find("car") then return Enum.Material.Foil end
	if isColor(c, "white") or isColor(c, "black") or isColor(c, "brown") then return Enum.Material.Concrete end
	if isColor(c, "red") then return Enum.Material.Limestone end
	if isColor(c, "blue") then return Enum.Material.Sandstone end
	if isColor(c, "yellow") then return Enum.Material.Salt end
	if isColor(c, "orange") then return Enum.Material.Wood end
	if isColor(c, "green") then return Enum.Material.Grass end
	if isColor(c, "purple") then return Enum.Material.DiamondPlate end
	if isColor(c, "pink") then return Enum.Material.Asphalt end
	if isColor(c, "gray") then return Enum.Material.Snow end
end

-- Aplicar material
local function aplicarMaterial(part)
	if part:IsA("BasePart") and not part:GetAttribute("MaterialAplicado") then
		local mat = getMaterialByColor(part)
		if mat then
			part.Material = mat
			part.Reflectance = 0.5
			part:SetAttribute("MaterialAplicado", true)
		end
	end
end

-- Oceanos
local function tratarOceanPart(part)
	if not part:IsA("BasePart") then return end
	if part.Name == "OceanBottom" or part.Name == "OceanFloorHole" then
		local deslocamento = Vector3.new(0, part.Size.Y * 1.5, 0)
		Terrain:FillBlock(part.CFrame + deslocamento, part.Size, Enum.Material.Water)
	end
	aplicarMaterial(part)
end

-- Partes existentes
for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("BasePart") then
		tratarOceanPart(obj)
	end
end

-- Novas partes
Workspace.DescendantAdded:Connect(function(obj)
	if obj:IsA("BasePart") then
		tratarOceanPart(obj)
	end
end)

-- Config de agua
if Terrain then
	Terrain.WaterTransparency = 0.6
	Terrain.WaterColor = Color3.fromRGB(20, 40, 80)
	Terrain.WaterWaveSize = 0.30
	Terrain.WaterWaveSpeed = 10
	Terrain.WaterReflectance = 30
end

-- Som ambiente
local ambiente = SoundService:FindFirstChild("AmbienteDin\195\162mico") or Instance.new("Sound", SoundService)
ambiente.Name = "AmbienteDin\195\162mico"
ambiente.Looped = true
ambiente.Volume = 0.5
ambiente.SoundId = "rbxassetid://8355232958"
ambiente:Play()

ambiente.Changed:Connect(function()
	if ambiente.Volume == 1 and not ambiente:FindFirstChild("EchoEffect") then
		local echo = Instance.new("ReverbSoundEffect")
		echo.Name = "EchoEffect"
		echo.DecayTime = 2
		echo.Density = 0.6
		echo.Diffusion = 0.8
		echo.Parent = ambiente
	end
end)

-- Clima
local function atualizarClima()
	local hora = Lighting:GetMinutesAfterMidnight() / 60
	local dia = hora > 6 and hora < 18
	if dia then
		Lighting.OutdoorAmbient = Color3.fromRGB(180, 200, 220)
		Lighting.ColorShift_Top = Color3.fromRGB(255, 240, 220)
		Lighting.ColorShift_Bottom = Color3.fromRGB(200, 220, 240)
		ambiente.SoundId = "rbxassetid://8355232958"
	else
		Lighting.OutdoorAmbient = Color3.fromRGB(150, 170, 200)
		Lighting.ColorShift_Top = Color3.fromRGB(150, 180, 220)
		Lighting.ColorShift_Bottom = Color3.fromRGB(80, 100, 120)
		ambiente.SoundId = "rbxassetid://179507208"
	end
end

Lighting:GetPropertyChangedSignal("ClockTime"):Connect(atualizarClima)
atualizarClima()

-- P√≥s-processamento (shaders)
for _, fx in ipairs(Camera:GetChildren()) do
	if fx:IsA("PostEffect") then fx:Destroy() end
end

local colorFX = Instance.new("ColorCorrectionEffect", Camera)
colorFX:SetAttribute("Shader", true)
colorFX.Contrast = 0.1
colorFX.Saturation = 0
colorFX.TintColor = Color3.fromRGB(220, 230, 240)

local bloomFX = Instance.new("BloomEffect", Camera)
bloomFX:SetAttribute("Shader", true)
bloomFX.Intensity = 0.25
bloomFX.Size = 12
bloomFX.Threshold = 0.7

local raysFX = Instance.new("SunRaysEffect", Camera)
raysFX:SetAttribute("Shader", true)
raysFX.Intensity = 0.04
raysFX.Spread = 0.7

local atm = Lighting:FindFirstChildOfClass("Atmosphere") or Instance.new("Atmosphere", Lighting)
atm.Density = 0.08
atm.Haze = 0.3
atm.EnvironmentDiffuseScale = 0.105
atm.EnvironmentSpecularScale = 0.522
  end
})

game.Workspace.FallenPartsDestroyHeight = -math.huge
